// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_vision_2eproto__INCLUDED
#define PROTOBUF_vision_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "structs.pb.h"

namespace bites {
namespace vision {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_vision_2eproto();
void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class Image;
class Landmark;
class DistanceBearing;
class Detection;
class Line;
class Line_LinePoint;
class Corner;
class Cross;
class CrossBar;
class FieldObject;
class Robot;
class Ball;
class Frame;

enum Image_Encoding {
  Image_Encoding_YCbCr = 1,
  Image_Encoding_YUV422 = 2,
  Image_Encoding_RGB = 3,
  Image_Encoding_BMP = 4
};
const ::google::protobuf::EnumDescriptor* Image_Encoding_descriptor();
bool Image_Encoding_IsValid(int value);
const Image_Encoding Image_Encoding_Encoding_MIN = Image_Encoding_YCbCr;
const Image_Encoding Image_Encoding_Encoding_MAX = Image_Encoding_BMP;

enum Landmark_ID {
  Landmark_ID_L_INNER_CORNER = 0,
  Landmark_ID_L_OUTER_CORNER = 1,
  Landmark_ID_T_CORNER = 2,
  Landmark_ID_CENTER_CIRCLE = 3,
  Landmark_ID_BLUE_GOAL_T = 4,
  Landmark_ID_YELLOW_GOAL_T = 5,
  Landmark_ID_BLUE_GOAL_RIGHT_L_OR_YELLOW_GOAL_LEFT_L = 6,
  Landmark_ID_BLUE_GOAL_LEFT_L_OR_YELLOW_GOAL_RIGHT_L = 7,
  Landmark_ID_BLUE_CORNER_TOP_L_OR_YELLOW_CORNER_BOTTOM_L = 8,
  Landmark_ID_BLUE_CORNER_BOTTOM_L_OR_YELLOW_CORNER_TOP_L = 9,
  Landmark_ID_CORNER_INNER_L = 10,
  Landmark_ID_GOAL_BOX_INNER_L = 11,
  Landmark_ID_BLUE_GOAL_OUTER_L = 12,
  Landmark_ID_YELLOW_GOAL_OUTER_L = 13,
  Landmark_ID_CENTER_T = 14,
  Landmark_ID_BLUE_CORNER_TOP_L = 15,
  Landmark_ID_BLUE_CORNER_BOTTOM_L = 16,
  Landmark_ID_BLUE_GOAL_LEFT_T = 17,
  Landmark_ID_BLUE_GOAL_RIGHT_T = 18,
  Landmark_ID_BLUE_GOAL_LEFT_L = 19,
  Landmark_ID_BLUE_GOAL_RIGHT_L = 20,
  Landmark_ID_CENTER_BOTTOM_T = 21,
  Landmark_ID_CENTER_TOP_T = 22,
  Landmark_ID_YELLOW_CORNER_BOTTOM_L = 23,
  Landmark_ID_YELLOW_CORNER_TOP_L = 24,
  Landmark_ID_YELLOW_GOAL_LEFT_T = 25,
  Landmark_ID_YELLOW_GOAL_RIGHT_T = 26,
  Landmark_ID_YELLOW_GOAL_LEFT_L = 27,
  Landmark_ID_YELLOW_GOAL_RIGHT_L = 28,
  Landmark_ID_CORNER_NO_IDEA_ID = 29,
  Landmark_ID_TOP_CC = 30,
  Landmark_ID_BOTTOM_CC = 31,
  Landmark_ID_BLUE_GOAL_LEFT_POST = 40,
  Landmark_ID_BLUE_GOAL_RIGHT_POST = 41,
  Landmark_ID_YELLOW_GOAL_LEFT_POST = 42,
  Landmark_ID_YELLOW_GOAL_RIGHT_POST = 43,
  Landmark_ID_BLUE_GOAL_POST = 44,
  Landmark_ID_YELLOW_GOAL_POST = 45,
  Landmark_ID_UNKNOWN_FIELD_OBJECT = 46,
  Landmark_ID_UNKNOWN_LINE = 50,
  Landmark_ID_SIDE_OR_ENDLINE = 51,
  Landmark_ID_SIDELINE_LINE = 52,
  Landmark_ID_ENDLINE_LINE = 53,
  Landmark_ID_GOALBOX_LINE = 54,
  Landmark_ID_GOALBOX_SIDE_LINE = 55,
  Landmark_ID_GOALBOX_TOP_LINE = 56,
  Landmark_ID_BLUE_GOAL_ENDLINE = 57,
  Landmark_ID_YELLOW_GOAL_ENDLINE = 58,
  Landmark_ID_BLUE_YELLOW_SIDELINE = 59,
  Landmark_ID_YELLOW_BLUE_SIDELINE = 60,
  Landmark_ID_CENTER_FIELD_LINE = 61,
  Landmark_ID_BLUE_GOALBOX_TOP_LINE = 62,
  Landmark_ID_BLUE_GOALBOX_LEFT_LINE = 63,
  Landmark_ID_BLUE_GOALBOX_RIGHT_LINE = 64,
  Landmark_ID_YELLOW_GOALBOX_TOP_LINE = 65,
  Landmark_ID_YELLOW_GOALBOX_LEFT_LINE = 65,
  Landmark_ID_YELLOW_GOALBOX_RIGHT_LINE = 66,
  Landmark_ID_BLUE_GOAL_CROSS = 80,
  Landmark_ID_YELLOW_GOAL_CROSS = 81,
  Landmark_ID_ABSTRACT_CROSS = 82
};
const ::google::protobuf::EnumDescriptor* Landmark_ID_descriptor();
bool Landmark_ID_IsValid(int value);
const Landmark_ID Landmark_ID_ID_MIN = Landmark_ID_L_INNER_CORNER;
const Landmark_ID Landmark_ID_ID_MAX = Landmark_ID_ABSTRACT_CROSS;

enum Landmark_IDCertainty {
  Landmark_IDCertainty_NOT_SURE = 0,
  Landmark_IDCertainty_MILDY_SURE = 1,
  Landmark_IDCertainty__SURE = 2
};
const ::google::protobuf::EnumDescriptor* Landmark_IDCertainty_descriptor();
bool Landmark_IDCertainty_IsValid(int value);
const Landmark_IDCertainty Landmark_IDCertainty_IDCertainty_MIN = Landmark_IDCertainty_NOT_SURE;
const Landmark_IDCertainty Landmark_IDCertainty_IDCertainty_MAX = Landmark_IDCertainty__SURE;

enum Landmark_DistanceCertainty {
  Landmark_DistanceCertainty_BOTH_UNSURE = 0,
  Landmark_DistanceCertainty_WIDTH_UNSURE = 1,
  Landmark_DistanceCertainty_HEIGHT_UNSURE = 2,
  Landmark_DistanceCertainty_BOTH_SURE = 3
};
const ::google::protobuf::EnumDescriptor* Landmark_DistanceCertainty_descriptor();
bool Landmark_DistanceCertainty_IsValid(int value);
const Landmark_DistanceCertainty Landmark_DistanceCertainty_DistanceCertainty_MIN = Landmark_DistanceCertainty_BOTH_UNSURE;
const Landmark_DistanceCertainty Landmark_DistanceCertainty_DistanceCertainty_MAX = Landmark_DistanceCertainty_BOTH_SURE;

enum Line_ScanDirection {
  Line_ScanDirection_HORIZONTAL = 0,
  Line_ScanDirection_VERTICAL = 1
};
const ::google::protobuf::EnumDescriptor* Line_ScanDirection_descriptor();
bool Line_ScanDirection_IsValid(int value);
const Line_ScanDirection Line_ScanDirection_ScanDirection_MIN = Line_ScanDirection_HORIZONTAL;
const Line_ScanDirection Line_ScanDirection_ScanDirection_MAX = Line_ScanDirection_VERTICAL;

enum Corner_Shape {
  Corner_Shape_INNER_L = 0,
  Corner_Shape_OUTER_L = 1,
  Corner_Shape_T = 2,
  Corner_Shape_CIRCLE = 3,
  Corner_Shape_UNKNOWN = 4
};
const ::google::protobuf::EnumDescriptor* Corner_Shape_descriptor();
bool Corner_Shape_IsValid(int value);
const Corner_Shape Corner_Shape_Shape_MIN = Corner_Shape_INNER_L;
const Corner_Shape Corner_Shape_Shape_MAX = Corner_Shape_UNKNOWN;

// ===================================================================

class Image : public ::google::protobuf::Message {
 public:
  Image();
  virtual ~Image();
  
  Image(const Image& from);
  
  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();
  void Swap(Image* other);
  
  // implements Message ----------------------------------------------
  
  Image* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Image_Encoding Encoding;
  static const Encoding YCbCr = Image_Encoding_YCbCr;
  static const Encoding YUV422 = Image_Encoding_YUV422;
  static const Encoding RGB = Image_Encoding_RGB;
  static const Encoding BMP = Image_Encoding_BMP;
  static inline const ::google::protobuf::EnumDescriptor*
  Encoding_descriptor() {
    return Image_Encoding_descriptor();
  }
  static inline bool Encoding_IsValid(int value) {
    return Image_Encoding_IsValid(value);
  }
  static const Encoding Encoding_MIN =
    Image_Encoding_Encoding_MIN;
  static const Encoding Encoding_MAX =
    Image_Encoding_Encoding_MAX;
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Image.Encoding encoding = 1 [default = YUV422];
  inline bool has_encoding() const;
  inline void clear_encoding();
  inline ::bites::vision::Image_Encoding encoding() const;
  inline void set_encoding(::bites::vision::Image_Encoding value);
  
  // required int32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // required int32 height = 3;
  inline bool has_height() const;
  inline void clear_height();
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int encoding_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class Landmark : public ::google::protobuf::Message {
 public:
  Landmark();
  virtual ~Landmark();
  
  Landmark(const Landmark& from);
  
  inline Landmark& operator=(const Landmark& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Landmark& default_instance();
  void Swap(Landmark* other);
  
  // implements Message ----------------------------------------------
  
  Landmark* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Landmark_ID ID;
  static const ID L_INNER_CORNER = Landmark_ID_L_INNER_CORNER;
  static const ID L_OUTER_CORNER = Landmark_ID_L_OUTER_CORNER;
  static const ID T_CORNER = Landmark_ID_T_CORNER;
  static const ID CENTER_CIRCLE = Landmark_ID_CENTER_CIRCLE;
  static const ID BLUE_GOAL_T = Landmark_ID_BLUE_GOAL_T;
  static const ID YELLOW_GOAL_T = Landmark_ID_YELLOW_GOAL_T;
  static const ID BLUE_GOAL_RIGHT_L_OR_YELLOW_GOAL_LEFT_L = Landmark_ID_BLUE_GOAL_RIGHT_L_OR_YELLOW_GOAL_LEFT_L;
  static const ID BLUE_GOAL_LEFT_L_OR_YELLOW_GOAL_RIGHT_L = Landmark_ID_BLUE_GOAL_LEFT_L_OR_YELLOW_GOAL_RIGHT_L;
  static const ID BLUE_CORNER_TOP_L_OR_YELLOW_CORNER_BOTTOM_L = Landmark_ID_BLUE_CORNER_TOP_L_OR_YELLOW_CORNER_BOTTOM_L;
  static const ID BLUE_CORNER_BOTTOM_L_OR_YELLOW_CORNER_TOP_L = Landmark_ID_BLUE_CORNER_BOTTOM_L_OR_YELLOW_CORNER_TOP_L;
  static const ID CORNER_INNER_L = Landmark_ID_CORNER_INNER_L;
  static const ID GOAL_BOX_INNER_L = Landmark_ID_GOAL_BOX_INNER_L;
  static const ID BLUE_GOAL_OUTER_L = Landmark_ID_BLUE_GOAL_OUTER_L;
  static const ID YELLOW_GOAL_OUTER_L = Landmark_ID_YELLOW_GOAL_OUTER_L;
  static const ID CENTER_T = Landmark_ID_CENTER_T;
  static const ID BLUE_CORNER_TOP_L = Landmark_ID_BLUE_CORNER_TOP_L;
  static const ID BLUE_CORNER_BOTTOM_L = Landmark_ID_BLUE_CORNER_BOTTOM_L;
  static const ID BLUE_GOAL_LEFT_T = Landmark_ID_BLUE_GOAL_LEFT_T;
  static const ID BLUE_GOAL_RIGHT_T = Landmark_ID_BLUE_GOAL_RIGHT_T;
  static const ID BLUE_GOAL_LEFT_L = Landmark_ID_BLUE_GOAL_LEFT_L;
  static const ID BLUE_GOAL_RIGHT_L = Landmark_ID_BLUE_GOAL_RIGHT_L;
  static const ID CENTER_BOTTOM_T = Landmark_ID_CENTER_BOTTOM_T;
  static const ID CENTER_TOP_T = Landmark_ID_CENTER_TOP_T;
  static const ID YELLOW_CORNER_BOTTOM_L = Landmark_ID_YELLOW_CORNER_BOTTOM_L;
  static const ID YELLOW_CORNER_TOP_L = Landmark_ID_YELLOW_CORNER_TOP_L;
  static const ID YELLOW_GOAL_LEFT_T = Landmark_ID_YELLOW_GOAL_LEFT_T;
  static const ID YELLOW_GOAL_RIGHT_T = Landmark_ID_YELLOW_GOAL_RIGHT_T;
  static const ID YELLOW_GOAL_LEFT_L = Landmark_ID_YELLOW_GOAL_LEFT_L;
  static const ID YELLOW_GOAL_RIGHT_L = Landmark_ID_YELLOW_GOAL_RIGHT_L;
  static const ID CORNER_NO_IDEA_ID = Landmark_ID_CORNER_NO_IDEA_ID;
  static const ID TOP_CC = Landmark_ID_TOP_CC;
  static const ID BOTTOM_CC = Landmark_ID_BOTTOM_CC;
  static const ID BLUE_GOAL_LEFT_POST = Landmark_ID_BLUE_GOAL_LEFT_POST;
  static const ID BLUE_GOAL_RIGHT_POST = Landmark_ID_BLUE_GOAL_RIGHT_POST;
  static const ID YELLOW_GOAL_LEFT_POST = Landmark_ID_YELLOW_GOAL_LEFT_POST;
  static const ID YELLOW_GOAL_RIGHT_POST = Landmark_ID_YELLOW_GOAL_RIGHT_POST;
  static const ID BLUE_GOAL_POST = Landmark_ID_BLUE_GOAL_POST;
  static const ID YELLOW_GOAL_POST = Landmark_ID_YELLOW_GOAL_POST;
  static const ID UNKNOWN_FIELD_OBJECT = Landmark_ID_UNKNOWN_FIELD_OBJECT;
  static const ID UNKNOWN_LINE = Landmark_ID_UNKNOWN_LINE;
  static const ID SIDE_OR_ENDLINE = Landmark_ID_SIDE_OR_ENDLINE;
  static const ID SIDELINE_LINE = Landmark_ID_SIDELINE_LINE;
  static const ID ENDLINE_LINE = Landmark_ID_ENDLINE_LINE;
  static const ID GOALBOX_LINE = Landmark_ID_GOALBOX_LINE;
  static const ID GOALBOX_SIDE_LINE = Landmark_ID_GOALBOX_SIDE_LINE;
  static const ID GOALBOX_TOP_LINE = Landmark_ID_GOALBOX_TOP_LINE;
  static const ID BLUE_GOAL_ENDLINE = Landmark_ID_BLUE_GOAL_ENDLINE;
  static const ID YELLOW_GOAL_ENDLINE = Landmark_ID_YELLOW_GOAL_ENDLINE;
  static const ID BLUE_YELLOW_SIDELINE = Landmark_ID_BLUE_YELLOW_SIDELINE;
  static const ID YELLOW_BLUE_SIDELINE = Landmark_ID_YELLOW_BLUE_SIDELINE;
  static const ID CENTER_FIELD_LINE = Landmark_ID_CENTER_FIELD_LINE;
  static const ID BLUE_GOALBOX_TOP_LINE = Landmark_ID_BLUE_GOALBOX_TOP_LINE;
  static const ID BLUE_GOALBOX_LEFT_LINE = Landmark_ID_BLUE_GOALBOX_LEFT_LINE;
  static const ID BLUE_GOALBOX_RIGHT_LINE = Landmark_ID_BLUE_GOALBOX_RIGHT_LINE;
  static const ID YELLOW_GOALBOX_TOP_LINE = Landmark_ID_YELLOW_GOALBOX_TOP_LINE;
  static const ID YELLOW_GOALBOX_LEFT_LINE = Landmark_ID_YELLOW_GOALBOX_LEFT_LINE;
  static const ID YELLOW_GOALBOX_RIGHT_LINE = Landmark_ID_YELLOW_GOALBOX_RIGHT_LINE;
  static const ID BLUE_GOAL_CROSS = Landmark_ID_BLUE_GOAL_CROSS;
  static const ID YELLOW_GOAL_CROSS = Landmark_ID_YELLOW_GOAL_CROSS;
  static const ID ABSTRACT_CROSS = Landmark_ID_ABSTRACT_CROSS;
  static inline const ::google::protobuf::EnumDescriptor*
  ID_descriptor() {
    return Landmark_ID_descriptor();
  }
  static inline bool ID_IsValid(int value) {
    return Landmark_ID_IsValid(value);
  }
  static const ID ID_MIN =
    Landmark_ID_ID_MIN;
  static const ID ID_MAX =
    Landmark_ID_ID_MAX;
  
  typedef Landmark_IDCertainty IDCertainty;
  static const IDCertainty NOT_SURE = Landmark_IDCertainty_NOT_SURE;
  static const IDCertainty MILDY_SURE = Landmark_IDCertainty_MILDY_SURE;
  static const IDCertainty _SURE = Landmark_IDCertainty__SURE;
  static inline const ::google::protobuf::EnumDescriptor*
  IDCertainty_descriptor() {
    return Landmark_IDCertainty_descriptor();
  }
  static inline bool IDCertainty_IsValid(int value) {
    return Landmark_IDCertainty_IsValid(value);
  }
  static const IDCertainty IDCertainty_MIN =
    Landmark_IDCertainty_IDCertainty_MIN;
  static const IDCertainty IDCertainty_MAX =
    Landmark_IDCertainty_IDCertainty_MAX;
  
  typedef Landmark_DistanceCertainty DistanceCertainty;
  static const DistanceCertainty BOTH_UNSURE = Landmark_DistanceCertainty_BOTH_UNSURE;
  static const DistanceCertainty WIDTH_UNSURE = Landmark_DistanceCertainty_WIDTH_UNSURE;
  static const DistanceCertainty HEIGHT_UNSURE = Landmark_DistanceCertainty_HEIGHT_UNSURE;
  static const DistanceCertainty BOTH_SURE = Landmark_DistanceCertainty_BOTH_SURE;
  static inline const ::google::protobuf::EnumDescriptor*
  DistanceCertainty_descriptor() {
    return Landmark_DistanceCertainty_descriptor();
  }
  static inline bool DistanceCertainty_IsValid(int value) {
    return Landmark_DistanceCertainty_IsValid(value);
  }
  static const DistanceCertainty DistanceCertainty_MIN =
    Landmark_DistanceCertainty_DistanceCertainty_MIN;
  static const DistanceCertainty DistanceCertainty_MAX =
    Landmark_DistanceCertainty_DistanceCertainty_MAX;
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Landmark.ID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline ::bites::vision::Landmark_ID id() const;
  inline void set_id(::bites::vision::Landmark_ID value);
  
  // required float field_x = 2;
  inline bool has_field_x() const;
  inline void clear_field_x();
  inline float field_x() const;
  inline void set_field_x(float value);
  
  // required float field_y = 3;
  inline bool has_field_y() const;
  inline void clear_field_y();
  inline float field_y() const;
  inline void set_field_y(float value);
  
  // optional .bites.vision.Landmark.IDCertainty id_certainty = 4;
  inline bool has_id_certainty() const;
  inline void clear_id_certainty();
  inline ::bites::vision::Landmark_IDCertainty id_certainty() const;
  inline void set_id_certainty(::bites::vision::Landmark_IDCertainty value);
  
  // optional .bites.vision.Landmark.DistanceCertainty distance_certainty = 5;
  inline bool has_distance_certainty() const;
  inline void clear_distance_certainty();
  inline ::bites::vision::Landmark_DistanceCertainty distance_certainty() const;
  inline void set_distance_certainty(::bites::vision::Landmark_DistanceCertainty value);
  
  template <typename _proto_TypeTraits>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id) const {
    return _extensions_.Has(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id) {
    _extensions_.ClearExtension(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id) const {
    return _extensions_.ExtensionSize(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id) const {
    return _proto_TypeTraits::Get(id.number(), _extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id) {
    return _proto_TypeTraits::Mutable(id.number(), &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id,
      typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Set(id.number(), value, &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _extensions_, index);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(),index,&_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id,
      int index, typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id) {
    return _proto_TypeTraits::Add(id.number(), &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Landmark, _proto_TypeTraits>& id,
      typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Add(id.number(), value, &_extensions_);
  }
 private:
  ::google::protobuf::internal::ExtensionSet _extensions_;
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int id_;
  float field_x_;
  float field_y_;
  int id_certainty_;
  int distance_certainty_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Landmark* default_instance_;
};
// -------------------------------------------------------------------

class DistanceBearing : public ::google::protobuf::Message {
 public:
  DistanceBearing();
  virtual ~DistanceBearing();
  
  DistanceBearing(const DistanceBearing& from);
  
  inline DistanceBearing& operator=(const DistanceBearing& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DistanceBearing& default_instance();
  void Swap(DistanceBearing* other);
  
  // implements Message ----------------------------------------------
  
  DistanceBearing* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float distance = 1;
  inline bool has_distance() const;
  inline void clear_distance();
  inline float distance() const;
  inline void set_distance(float value);
  
  // required float bearing = 2;
  inline bool has_bearing() const;
  inline void clear_bearing();
  inline float bearing() const;
  inline void set_bearing(float value);
  
  // required float distance_sd = 3;
  inline bool has_distance_sd() const;
  inline void clear_distance_sd();
  inline float distance_sd() const;
  inline void set_distance_sd(float value);
  
  // required float bearing_sd = 4;
  inline bool has_bearing_sd() const;
  inline void clear_bearing_sd();
  inline float bearing_sd() const;
  inline void set_bearing_sd(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float distance_;
  float bearing_;
  float distance_sd_;
  float bearing_sd_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DistanceBearing* default_instance_;
};
// -------------------------------------------------------------------

class Detection : public ::google::protobuf::Message {
 public:
  Detection();
  virtual ~Detection();
  
  Detection(const Detection& from);
  
  inline Detection& operator=(const Detection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Detection& default_instance();
  void Swap(Detection* other);
  
  // implements Message ----------------------------------------------
  
  Detection* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // required float width = 3;
  inline bool has_width() const;
  inline void clear_width();
  inline float width() const;
  inline void set_width(float value);
  
  // required float height = 4;
  inline bool has_height() const;
  inline void clear_height();
  inline float height() const;
  inline void set_height(float value);
  
  // required int32 center_x = 5;
  inline bool has_center_x() const;
  inline void clear_center_x();
  inline ::google::protobuf::int32 center_x() const;
  inline void set_center_x(::google::protobuf::int32 value);
  
  // required int32 center_y = 6;
  inline bool has_center_y() const;
  inline void clear_center_y();
  inline ::google::protobuf::int32 center_y() const;
  inline void set_center_y(::google::protobuf::int32 value);
  
  // required float angle_x = 7;
  inline bool has_angle_x() const;
  inline void clear_angle_x();
  inline float angle_x() const;
  inline void set_angle_x(float value);
  
  // required float angle_y = 8;
  inline bool has_angle_y() const;
  inline void clear_angle_y();
  inline float angle_y() const;
  inline void set_angle_y(float value);
  
  // required float foc_dist = 9;
  inline bool has_foc_dist() const;
  inline void clear_foc_dist();
  inline float foc_dist() const;
  inline void set_foc_dist(float value);
  
  // required float elevation = 10;
  inline bool has_elevation() const;
  inline void clear_elevation();
  inline float elevation() const;
  inline void set_elevation(float value);
  
  // required .bites.vision.DistanceBearing db = 11;
  inline bool has_db() const;
  inline void clear_db();
  inline const ::bites::vision::DistanceBearing& db() const;
  inline ::bites::vision::DistanceBearing* mutable_db();
  
  template <typename _proto_TypeTraits>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id) const {
    return _extensions_.Has(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id) {
    _extensions_.ClearExtension(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id) const {
    return _extensions_.ExtensionSize(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id) const {
    return _proto_TypeTraits::Get(id.number(), _extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id) {
    return _proto_TypeTraits::Mutable(id.number(), &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id,
      typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Set(id.number(), value, &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _extensions_, index);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(),index,&_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id,
      int index, typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id) {
    return _proto_TypeTraits::Add(id.number(), &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        Detection, _proto_TypeTraits>& id,
      typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Add(id.number(), value, &_extensions_);
  }
 private:
  ::google::protobuf::internal::ExtensionSet _extensions_;
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  float width_;
  float height_;
  ::google::protobuf::int32 center_x_;
  ::google::protobuf::int32 center_y_;
  float angle_x_;
  float angle_y_;
  float foc_dist_;
  float elevation_;
  ::bites::vision::DistanceBearing* db_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Detection* default_instance_;
};
// -------------------------------------------------------------------

class Line_LinePoint : public ::google::protobuf::Message {
 public:
  Line_LinePoint();
  virtual ~Line_LinePoint();
  
  Line_LinePoint(const Line_LinePoint& from);
  
  inline Line_LinePoint& operator=(const Line_LinePoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Line_LinePoint& default_instance();
  void Swap(Line_LinePoint* other);
  
  // implements Message ----------------------------------------------
  
  Line_LinePoint* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // required float line_width = 3;
  inline bool has_line_width() const;
  inline void clear_line_width();
  inline float line_width() const;
  inline void set_line_width(float value);
  
  // required float distance = 4;
  inline bool has_distance() const;
  inline void clear_distance();
  inline float distance() const;
  inline void set_distance(float value);
  
  // required .bites.vision.Line.ScanDirection found_with_scan = 5;
  inline bool has_found_with_scan() const;
  inline void clear_found_with_scan();
  inline ::bites::vision::Line_ScanDirection found_with_scan() const;
  inline void set_found_with_scan(::bites::vision::Line_ScanDirection value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  float line_width_;
  float distance_;
  int found_with_scan_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Line_LinePoint* default_instance_;
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message {
 public:
  Line();
  virtual ~Line();
  
  Line(const Line& from);
  
  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Line& default_instance();
  void Swap(Line* other);
  
  // implements Message ----------------------------------------------
  
  Line* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Line_LinePoint LinePoint;
  
  typedef Line_ScanDirection ScanDirection;
  static const ScanDirection HORIZONTAL = Line_ScanDirection_HORIZONTAL;
  static const ScanDirection VERTICAL = Line_ScanDirection_VERTICAL;
  static inline const ::google::protobuf::EnumDescriptor*
  ScanDirection_descriptor() {
    return Line_ScanDirection_descriptor();
  }
  static inline bool ScanDirection_IsValid(int value) {
    return Line_ScanDirection_IsValid(value);
  }
  static const ScanDirection ScanDirection_MIN =
    Line_ScanDirection_ScanDirection_MIN;
  static const ScanDirection ScanDirection_MAX =
    Line_ScanDirection_ScanDirection_MAX;
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Landmark self = 1;
  inline bool has_self() const;
  inline void clear_self();
  inline const ::bites::vision::Landmark& self() const;
  inline ::bites::vision::Landmark* mutable_self();
  
  // repeated .bites.vision.Landmark possibles = 2;
  inline int possibles_size() const;
  inline void clear_possibles();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >& possibles() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >* mutable_possibles();
  inline const ::bites::vision::Landmark& possibles(int index) const;
  inline ::bites::vision::Landmark* mutable_possibles(int index);
  inline ::bites::vision::Landmark* add_possibles();
  
  // repeated .bites.vision.Line.LinePoint points = 3;
  inline int points_size() const;
  inline void clear_points();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line_LinePoint >& points() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line_LinePoint >* mutable_points();
  inline const ::bites::vision::Line_LinePoint& points(int index) const;
  inline ::bites::vision::Line_LinePoint* mutable_points(int index);
  inline ::bites::vision::Line_LinePoint* add_points();
  
  // optional float angle = 4;
  inline bool has_angle() const;
  inline void clear_angle();
  inline float angle() const;
  inline void set_angle(float value);
  
  // optional float a = 5;
  inline bool has_a() const;
  inline void clear_a();
  inline float a() const;
  inline void set_a(float value);
  
  // optional float b = 6;
  inline bool has_b() const;
  inline void clear_b();
  inline float b() const;
  inline void set_b(float value);
  
  // optional float length = 7;
  inline bool has_length() const;
  inline void clear_length();
  inline float length() const;
  inline void set_length(float value);
  
  // optional float avg_vertical_width = 8;
  inline bool has_avg_vertical_width() const;
  inline void clear_avg_vertical_width();
  inline float avg_vertical_width() const;
  inline void set_avg_vertical_width(float value);
  
  // optional float avg_horizontal_width = 9;
  inline bool has_avg_horizontal_width() const;
  inline void clear_avg_horizontal_width();
  inline float avg_horizontal_width() const;
  inline void set_avg_horizontal_width(float value);
  
  // optional .bites.vision.Line.LinePoint thinnest_hor_point = 10;
  inline bool has_thinnest_hor_point() const;
  inline void clear_thinnest_hor_point();
  inline const ::bites::vision::Line_LinePoint& thinnest_hor_point() const;
  inline ::bites::vision::Line_LinePoint* mutable_thinnest_hor_point();
  
  // optional .bites.vision.Line.LinePoint thickest_hor_point = 11;
  inline bool has_thickest_hor_point() const;
  inline void clear_thickest_hor_point();
  inline const ::bites::vision::Line_LinePoint& thickest_hor_point() const;
  inline ::bites::vision::Line_LinePoint* mutable_thickest_hor_point();
  
  // optional .bites.vision.Line.LinePoint thinnest_vert_point = 12;
  inline bool has_thinnest_vert_point() const;
  inline void clear_thinnest_vert_point();
  inline const ::bites::vision::Line_LinePoint& thinnest_vert_point() const;
  inline ::bites::vision::Line_LinePoint* mutable_thinnest_vert_point();
  
  // optional .bites.vision.Line.LinePoint thickest_vert_point = 13;
  inline bool has_thickest_vert_point() const;
  inline void clear_thickest_vert_point();
  inline const ::bites::vision::Line_LinePoint& thickest_vert_point() const;
  inline ::bites::vision::Line_LinePoint* mutable_thickest_vert_point();
  
  // required .bites.vision.DistanceBearing db = 14;
  inline bool has_db() const;
  inline void clear_db();
  inline const ::bites::vision::DistanceBearing& db() const;
  inline ::bites::vision::DistanceBearing* mutable_db();
  
  // required bool cc_line = 15;
  inline bool has_cc_line() const;
  inline void clear_cc_line();
  inline bool cc_line() const;
  inline void set_cc_line(bool value);
  
  static ::google::protobuf::internal::ExtensionIdentifier< ::bites::vision::Landmark,
    ::google::protobuf::internal::PrimitiveTypeTraits< float > > field_x2;
  static ::google::protobuf::internal::ExtensionIdentifier< ::bites::vision::Landmark,
    ::google::protobuf::internal::PrimitiveTypeTraits< float > > field_y2;
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Landmark* self_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark > possibles_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Line_LinePoint > points_;
  float angle_;
  float a_;
  float b_;
  float length_;
  float avg_vertical_width_;
  float avg_horizontal_width_;
  ::bites::vision::Line_LinePoint* thinnest_hor_point_;
  ::bites::vision::Line_LinePoint* thickest_hor_point_;
  ::bites::vision::Line_LinePoint* thinnest_vert_point_;
  ::bites::vision::Line_LinePoint* thickest_vert_point_;
  ::bites::vision::DistanceBearing* db_;
  bool cc_line_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Line* default_instance_;
};
// -------------------------------------------------------------------

class Corner : public ::google::protobuf::Message {
 public:
  Corner();
  virtual ~Corner();
  
  Corner(const Corner& from);
  
  inline Corner& operator=(const Corner& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Corner& default_instance();
  void Swap(Corner* other);
  
  // implements Message ----------------------------------------------
  
  Corner* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Corner_Shape Shape;
  static const Shape INNER_L = Corner_Shape_INNER_L;
  static const Shape OUTER_L = Corner_Shape_OUTER_L;
  static const Shape T = Corner_Shape_T;
  static const Shape CIRCLE = Corner_Shape_CIRCLE;
  static const Shape UNKNOWN = Corner_Shape_UNKNOWN;
  static inline const ::google::protobuf::EnumDescriptor*
  Shape_descriptor() {
    return Corner_Shape_descriptor();
  }
  static inline bool Shape_IsValid(int value) {
    return Corner_Shape_IsValid(value);
  }
  static const Shape Shape_MIN =
    Corner_Shape_Shape_MIN;
  static const Shape Shape_MAX =
    Corner_Shape_Shape_MAX;
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Landmark self = 1;
  inline bool has_self() const;
  inline void clear_self();
  inline const ::bites::vision::Landmark& self() const;
  inline ::bites::vision::Landmark* mutable_self();
  
  // required .bites.vision.Detection detect = 2;
  inline bool has_detect() const;
  inline void clear_detect();
  inline const ::bites::vision::Detection& detect() const;
  inline ::bites::vision::Detection* mutable_detect();
  
  // repeated .bites.vision.Landmark possibles = 3;
  inline int possibles_size() const;
  inline void clear_possibles();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >& possibles() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >* mutable_possibles();
  inline const ::bites::vision::Landmark& possibles(int index) const;
  inline ::bites::vision::Landmark* mutable_possibles(int index);
  inline ::bites::vision::Landmark* add_possibles();
  
  // repeated .bites.vision.Line lines = 4;
  inline int lines_size() const;
  inline void clear_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >& lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >* mutable_lines();
  inline const ::bites::vision::Line& lines(int index) const;
  inline ::bites::vision::Line* mutable_lines(int index);
  inline ::bites::vision::Line* add_lines();
  
  // repeated float dists = 5;
  inline int dists_size() const;
  inline void clear_dists();
  inline const ::google::protobuf::RepeatedField< float >& dists() const;
  inline ::google::protobuf::RepeatedField< float >* mutable_dists();
  inline float dists(int index) const;
  inline void set_dists(int index, float value);
  inline void add_dists(float value);
  
  // repeated .bites.vision.Line t_lines = 6;
  inline int t_lines_size() const;
  inline void clear_t_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >& t_lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >* mutable_t_lines();
  inline const ::bites::vision::Line& t_lines(int index) const;
  inline ::bites::vision::Line* mutable_t_lines(int index);
  inline ::bites::vision::Line* add_t_lines();
  
  // required float angle_between_lines = 7;
  inline bool has_angle_between_lines() const;
  inline void clear_angle_between_lines();
  inline float angle_between_lines() const;
  inline void set_angle_between_lines(float value);
  
  static ::google::protobuf::internal::ExtensionIdentifier< ::bites::vision::Landmark,
    ::google::protobuf::internal::EnumTypeTraits< ::bites::vision::Corner_Shape > > corner_type;
  static ::google::protobuf::internal::ExtensionIdentifier< ::bites::vision::Landmark,
    ::google::protobuf::internal::RepeatedMessageTypeTraits< ::bites::vision::Landmark > > corner_lines;
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Landmark* self_;
  ::bites::vision::Detection* detect_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark > possibles_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Line > lines_;
  ::google::protobuf::RepeatedField< float > dists_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Line > t_lines_;
  float angle_between_lines_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Corner* default_instance_;
};
// -------------------------------------------------------------------

class Cross : public ::google::protobuf::Message {
 public:
  Cross();
  virtual ~Cross();
  
  Cross(const Cross& from);
  
  inline Cross& operator=(const Cross& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Cross& default_instance();
  void Swap(Cross* other);
  
  // implements Message ----------------------------------------------
  
  Cross* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Landmark self = 1;
  inline bool has_self() const;
  inline void clear_self();
  inline const ::bites::vision::Landmark& self() const;
  inline ::bites::vision::Landmark* mutable_self();
  
  // required .bites.vision.Detection detect = 2;
  inline bool has_detect() const;
  inline void clear_detect();
  inline const ::bites::vision::Detection& detect() const;
  inline ::bites::vision::Detection* mutable_detect();
  
  // repeated .bites.vision.Landmark possibles = 3;
  inline int possibles_size() const;
  inline void clear_possibles();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >& possibles() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >* mutable_possibles();
  inline const ::bites::vision::Landmark& possibles(int index) const;
  inline ::bites::vision::Landmark* mutable_possibles(int index);
  inline ::bites::vision::Landmark* add_possibles();
  
  // required .bites.Rectangle bounds = 4;
  inline bool has_bounds() const;
  inline void clear_bounds();
  inline const ::bites::Rectangle& bounds() const;
  inline ::bites::Rectangle* mutable_bounds();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Landmark* self_;
  ::bites::vision::Detection* detect_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark > possibles_;
  ::bites::Rectangle* bounds_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Cross* default_instance_;
};
// -------------------------------------------------------------------

class CrossBar : public ::google::protobuf::Message {
 public:
  CrossBar();
  virtual ~CrossBar();
  
  CrossBar(const CrossBar& from);
  
  inline CrossBar& operator=(const CrossBar& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CrossBar& default_instance();
  void Swap(CrossBar* other);
  
  // implements Message ----------------------------------------------
  
  CrossBar* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Detection detect = 1;
  inline bool has_detect() const;
  inline void clear_detect();
  inline const ::bites::vision::Detection& detect() const;
  inline ::bites::vision::Detection* mutable_detect();
  
  // required .bites.Rectangle bounds = 2;
  inline bool has_bounds() const;
  inline void clear_bounds();
  inline const ::bites::Rectangle& bounds() const;
  inline ::bites::Rectangle* mutable_bounds();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Detection* detect_;
  ::bites::Rectangle* bounds_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CrossBar* default_instance_;
};
// -------------------------------------------------------------------

class FieldObject : public ::google::protobuf::Message {
 public:
  FieldObject();
  virtual ~FieldObject();
  
  FieldObject(const FieldObject& from);
  
  inline FieldObject& operator=(const FieldObject& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldObject& default_instance();
  void Swap(FieldObject* other);
  
  // implements Message ----------------------------------------------
  
  FieldObject* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Landmark self = 1;
  inline bool has_self() const;
  inline void clear_self();
  inline const ::bites::vision::Landmark& self() const;
  inline ::bites::vision::Landmark* mutable_self();
  
  // required .bites.vision.Landmark possibles = 2;
  inline bool has_possibles() const;
  inline void clear_possibles();
  inline const ::bites::vision::Landmark& possibles() const;
  inline ::bites::vision::Landmark* mutable_possibles();
  
  // required .bites.Rectangle bounds = 3;
  inline bool has_bounds() const;
  inline void clear_bounds();
  inline const ::bites::Rectangle& bounds() const;
  inline ::bites::Rectangle* mutable_bounds();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Landmark* self_;
  ::bites::vision::Landmark* possibles_;
  ::bites::Rectangle* bounds_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FieldObject* default_instance_;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message {
 public:
  Robot();
  virtual ~Robot();
  
  Robot(const Robot& from);
  
  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();
  void Swap(Robot* other);
  
  // implements Message ----------------------------------------------
  
  Robot* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Detection detect = 1;
  inline bool has_detect() const;
  inline void clear_detect();
  inline const ::bites::vision::Detection& detect() const;
  inline ::bites::vision::Detection* mutable_detect();
  
  // required .bites.Rectangle bounds = 2;
  inline bool has_bounds() const;
  inline void clear_bounds();
  inline const ::bites::Rectangle& bounds() const;
  inline ::bites::Rectangle* mutable_bounds();
  
  // required int32 back_left = 3;
  inline bool has_back_left() const;
  inline void clear_back_left();
  inline ::google::protobuf::int32 back_left() const;
  inline void set_back_left(::google::protobuf::int32 value);
  
  // required int32 back_right = 4;
  inline bool has_back_right() const;
  inline void clear_back_right();
  inline ::google::protobuf::int32 back_right() const;
  inline void set_back_right(::google::protobuf::int32 value);
  
  // required int32 back_dir = 5;
  inline bool has_back_dir() const;
  inline void clear_back_dir();
  inline ::google::protobuf::int32 back_dir() const;
  inline void set_back_dir(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Detection* detect_;
  ::bites::Rectangle* bounds_;
  ::google::protobuf::int32 back_left_;
  ::google::protobuf::int32 back_right_;
  ::google::protobuf::int32 back_dir_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Robot* default_instance_;
};
// -------------------------------------------------------------------

class Ball : public ::google::protobuf::Message {
 public:
  Ball();
  virtual ~Ball();
  
  Ball(const Ball& from);
  
  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ball& default_instance();
  void Swap(Ball* other);
  
  // implements Message ----------------------------------------------
  
  Ball* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bites.vision.Detection detect = 1;
  inline bool has_detect() const;
  inline void clear_detect();
  inline const ::bites::vision::Detection& detect() const;
  inline ::bites::vision::Detection* mutable_detect();
  
  // required float radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  inline float radius() const;
  inline void set_radius(float value);
  
  // required int32 confidence = 3;
  inline bool has_confidence() const;
  inline void clear_confidence();
  inline ::google::protobuf::int32 confidence() const;
  inline void set_confidence(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Detection* detect_;
  float radius_;
  ::google::protobuf::int32 confidence_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Ball* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message {
 public:
  Frame();
  virtual ~Frame();
  
  Frame(const Frame& from);
  
  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();
  void Swap(Frame* other);
  
  // implements Message ----------------------------------------------
  
  Frame* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .bites.vision.Image image = 1;
  inline bool has_image() const;
  inline void clear_image();
  inline const ::bites::vision::Image& image() const;
  inline ::bites::vision::Image* mutable_image();
  
  // repeated .bites.vision.Ball balls = 2;
  inline int balls_size() const;
  inline void clear_balls();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Ball >& balls() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Ball >* mutable_balls();
  inline const ::bites::vision::Ball& balls(int index) const;
  inline ::bites::vision::Ball* mutable_balls(int index);
  inline ::bites::vision::Ball* add_balls();
  
  // repeated .bites.vision.FieldObject objects = 3;
  inline int objects_size() const;
  inline void clear_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::FieldObject >& objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::FieldObject >* mutable_objects();
  inline const ::bites::vision::FieldObject& objects(int index) const;
  inline ::bites::vision::FieldObject* mutable_objects(int index);
  inline ::bites::vision::FieldObject* add_objects();
  
  // repeated .bites.vision.Line lines = 4;
  inline int lines_size() const;
  inline void clear_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >& lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >* mutable_lines();
  inline const ::bites::vision::Line& lines(int index) const;
  inline ::bites::vision::Line* mutable_lines(int index);
  inline ::bites::vision::Line* add_lines();
  
  // repeated .bites.vision.Corner corners = 5;
  inline int corners_size() const;
  inline void clear_corners();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Corner >& corners() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Corner >* mutable_corners();
  inline const ::bites::vision::Corner& corners(int index) const;
  inline ::bites::vision::Corner* mutable_corners(int index);
  inline ::bites::vision::Corner* add_corners();
  
  // repeated .bites.vision.Robot robots = 6;
  inline int robots_size() const;
  inline void clear_robots();
  inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Robot >& robots() const;
  inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Robot >* mutable_robots();
  inline const ::bites::vision::Robot& robots(int index) const;
  inline ::bites::vision::Robot* mutable_robots(int index);
  inline ::bites::vision::Robot* add_robots();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bites::vision::Image* image_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Ball > balls_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::FieldObject > objects_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Line > lines_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Corner > corners_;
  ::google::protobuf::RepeatedPtrField< ::bites::vision::Robot > robots_;
  friend void protobuf_BuildDesc_vision_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// Image

// required .bites.vision.Image.Encoding encoding = 1 [default = YUV422];
inline bool Image::has_encoding() const {
  return _has_bit(0);
}
inline void Image::clear_encoding() {
  encoding_ = 2;
  _clear_bit(0);
}
inline ::bites::vision::Image_Encoding Image::encoding() const {
  return static_cast< ::bites::vision::Image_Encoding >(encoding_);
}
inline void Image::set_encoding(::bites::vision::Image_Encoding value) {
  GOOGLE_DCHECK(::bites::vision::Image_Encoding_IsValid(value));
  _set_bit(0);
  encoding_ = value;
}

// required int32 width = 2;
inline bool Image::has_width() const {
  return _has_bit(1);
}
inline void Image::clear_width() {
  width_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Image::width() const {
  return width_;
}
inline void Image::set_width(::google::protobuf::int32 value) {
  _set_bit(1);
  width_ = value;
}

// required int32 height = 3;
inline bool Image::has_height() const {
  return _has_bit(2);
}
inline void Image::clear_height() {
  height_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Image::height() const {
  return height_;
}
inline void Image::set_height(::google::protobuf::int32 value) {
  _set_bit(2);
  height_ = value;
}

// required bytes data = 4;
inline bool Image::has_data() const {
  return _has_bit(3);
}
inline void Image::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Image::data() const {
  return *data_;
}
inline void Image::set_data(const ::std::string& value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Image::set_data(const char* value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Image::set_data(const void* value, size_t size) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_data() {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// Landmark

// required .bites.vision.Landmark.ID id = 1;
inline bool Landmark::has_id() const {
  return _has_bit(0);
}
inline void Landmark::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::bites::vision::Landmark_ID Landmark::id() const {
  return static_cast< ::bites::vision::Landmark_ID >(id_);
}
inline void Landmark::set_id(::bites::vision::Landmark_ID value) {
  GOOGLE_DCHECK(::bites::vision::Landmark_ID_IsValid(value));
  _set_bit(0);
  id_ = value;
}

// required float field_x = 2;
inline bool Landmark::has_field_x() const {
  return _has_bit(1);
}
inline void Landmark::clear_field_x() {
  field_x_ = 0;
  _clear_bit(1);
}
inline float Landmark::field_x() const {
  return field_x_;
}
inline void Landmark::set_field_x(float value) {
  _set_bit(1);
  field_x_ = value;
}

// required float field_y = 3;
inline bool Landmark::has_field_y() const {
  return _has_bit(2);
}
inline void Landmark::clear_field_y() {
  field_y_ = 0;
  _clear_bit(2);
}
inline float Landmark::field_y() const {
  return field_y_;
}
inline void Landmark::set_field_y(float value) {
  _set_bit(2);
  field_y_ = value;
}

// optional .bites.vision.Landmark.IDCertainty id_certainty = 4;
inline bool Landmark::has_id_certainty() const {
  return _has_bit(3);
}
inline void Landmark::clear_id_certainty() {
  id_certainty_ = 0;
  _clear_bit(3);
}
inline ::bites::vision::Landmark_IDCertainty Landmark::id_certainty() const {
  return static_cast< ::bites::vision::Landmark_IDCertainty >(id_certainty_);
}
inline void Landmark::set_id_certainty(::bites::vision::Landmark_IDCertainty value) {
  GOOGLE_DCHECK(::bites::vision::Landmark_IDCertainty_IsValid(value));
  _set_bit(3);
  id_certainty_ = value;
}

// optional .bites.vision.Landmark.DistanceCertainty distance_certainty = 5;
inline bool Landmark::has_distance_certainty() const {
  return _has_bit(4);
}
inline void Landmark::clear_distance_certainty() {
  distance_certainty_ = 0;
  _clear_bit(4);
}
inline ::bites::vision::Landmark_DistanceCertainty Landmark::distance_certainty() const {
  return static_cast< ::bites::vision::Landmark_DistanceCertainty >(distance_certainty_);
}
inline void Landmark::set_distance_certainty(::bites::vision::Landmark_DistanceCertainty value) {
  GOOGLE_DCHECK(::bites::vision::Landmark_DistanceCertainty_IsValid(value));
  _set_bit(4);
  distance_certainty_ = value;
}

// -------------------------------------------------------------------

// DistanceBearing

// required float distance = 1;
inline bool DistanceBearing::has_distance() const {
  return _has_bit(0);
}
inline void DistanceBearing::clear_distance() {
  distance_ = 0;
  _clear_bit(0);
}
inline float DistanceBearing::distance() const {
  return distance_;
}
inline void DistanceBearing::set_distance(float value) {
  _set_bit(0);
  distance_ = value;
}

// required float bearing = 2;
inline bool DistanceBearing::has_bearing() const {
  return _has_bit(1);
}
inline void DistanceBearing::clear_bearing() {
  bearing_ = 0;
  _clear_bit(1);
}
inline float DistanceBearing::bearing() const {
  return bearing_;
}
inline void DistanceBearing::set_bearing(float value) {
  _set_bit(1);
  bearing_ = value;
}

// required float distance_sd = 3;
inline bool DistanceBearing::has_distance_sd() const {
  return _has_bit(2);
}
inline void DistanceBearing::clear_distance_sd() {
  distance_sd_ = 0;
  _clear_bit(2);
}
inline float DistanceBearing::distance_sd() const {
  return distance_sd_;
}
inline void DistanceBearing::set_distance_sd(float value) {
  _set_bit(2);
  distance_sd_ = value;
}

// required float bearing_sd = 4;
inline bool DistanceBearing::has_bearing_sd() const {
  return _has_bit(3);
}
inline void DistanceBearing::clear_bearing_sd() {
  bearing_sd_ = 0;
  _clear_bit(3);
}
inline float DistanceBearing::bearing_sd() const {
  return bearing_sd_;
}
inline void DistanceBearing::set_bearing_sd(float value) {
  _set_bit(3);
  bearing_sd_ = value;
}

// -------------------------------------------------------------------

// Detection

// required int32 x = 1;
inline bool Detection::has_x() const {
  return _has_bit(0);
}
inline void Detection::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Detection::x() const {
  return x_;
}
inline void Detection::set_x(::google::protobuf::int32 value) {
  _set_bit(0);
  x_ = value;
}

// required int32 y = 2;
inline bool Detection::has_y() const {
  return _has_bit(1);
}
inline void Detection::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Detection::y() const {
  return y_;
}
inline void Detection::set_y(::google::protobuf::int32 value) {
  _set_bit(1);
  y_ = value;
}

// required float width = 3;
inline bool Detection::has_width() const {
  return _has_bit(2);
}
inline void Detection::clear_width() {
  width_ = 0;
  _clear_bit(2);
}
inline float Detection::width() const {
  return width_;
}
inline void Detection::set_width(float value) {
  _set_bit(2);
  width_ = value;
}

// required float height = 4;
inline bool Detection::has_height() const {
  return _has_bit(3);
}
inline void Detection::clear_height() {
  height_ = 0;
  _clear_bit(3);
}
inline float Detection::height() const {
  return height_;
}
inline void Detection::set_height(float value) {
  _set_bit(3);
  height_ = value;
}

// required int32 center_x = 5;
inline bool Detection::has_center_x() const {
  return _has_bit(4);
}
inline void Detection::clear_center_x() {
  center_x_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Detection::center_x() const {
  return center_x_;
}
inline void Detection::set_center_x(::google::protobuf::int32 value) {
  _set_bit(4);
  center_x_ = value;
}

// required int32 center_y = 6;
inline bool Detection::has_center_y() const {
  return _has_bit(5);
}
inline void Detection::clear_center_y() {
  center_y_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 Detection::center_y() const {
  return center_y_;
}
inline void Detection::set_center_y(::google::protobuf::int32 value) {
  _set_bit(5);
  center_y_ = value;
}

// required float angle_x = 7;
inline bool Detection::has_angle_x() const {
  return _has_bit(6);
}
inline void Detection::clear_angle_x() {
  angle_x_ = 0;
  _clear_bit(6);
}
inline float Detection::angle_x() const {
  return angle_x_;
}
inline void Detection::set_angle_x(float value) {
  _set_bit(6);
  angle_x_ = value;
}

// required float angle_y = 8;
inline bool Detection::has_angle_y() const {
  return _has_bit(7);
}
inline void Detection::clear_angle_y() {
  angle_y_ = 0;
  _clear_bit(7);
}
inline float Detection::angle_y() const {
  return angle_y_;
}
inline void Detection::set_angle_y(float value) {
  _set_bit(7);
  angle_y_ = value;
}

// required float foc_dist = 9;
inline bool Detection::has_foc_dist() const {
  return _has_bit(8);
}
inline void Detection::clear_foc_dist() {
  foc_dist_ = 0;
  _clear_bit(8);
}
inline float Detection::foc_dist() const {
  return foc_dist_;
}
inline void Detection::set_foc_dist(float value) {
  _set_bit(8);
  foc_dist_ = value;
}

// required float elevation = 10;
inline bool Detection::has_elevation() const {
  return _has_bit(9);
}
inline void Detection::clear_elevation() {
  elevation_ = 0;
  _clear_bit(9);
}
inline float Detection::elevation() const {
  return elevation_;
}
inline void Detection::set_elevation(float value) {
  _set_bit(9);
  elevation_ = value;
}

// required .bites.vision.DistanceBearing db = 11;
inline bool Detection::has_db() const {
  return _has_bit(10);
}
inline void Detection::clear_db() {
  if (db_ != NULL) db_->::bites::vision::DistanceBearing::Clear();
  _clear_bit(10);
}
inline const ::bites::vision::DistanceBearing& Detection::db() const {
  return db_ != NULL ? *db_ : *default_instance_->db_;
}
inline ::bites::vision::DistanceBearing* Detection::mutable_db() {
  _set_bit(10);
  if (db_ == NULL) db_ = new ::bites::vision::DistanceBearing;
  return db_;
}

// -------------------------------------------------------------------

// Line_LinePoint

// required int32 x = 1;
inline bool Line_LinePoint::has_x() const {
  return _has_bit(0);
}
inline void Line_LinePoint::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Line_LinePoint::x() const {
  return x_;
}
inline void Line_LinePoint::set_x(::google::protobuf::int32 value) {
  _set_bit(0);
  x_ = value;
}

// required int32 y = 2;
inline bool Line_LinePoint::has_y() const {
  return _has_bit(1);
}
inline void Line_LinePoint::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Line_LinePoint::y() const {
  return y_;
}
inline void Line_LinePoint::set_y(::google::protobuf::int32 value) {
  _set_bit(1);
  y_ = value;
}

// required float line_width = 3;
inline bool Line_LinePoint::has_line_width() const {
  return _has_bit(2);
}
inline void Line_LinePoint::clear_line_width() {
  line_width_ = 0;
  _clear_bit(2);
}
inline float Line_LinePoint::line_width() const {
  return line_width_;
}
inline void Line_LinePoint::set_line_width(float value) {
  _set_bit(2);
  line_width_ = value;
}

// required float distance = 4;
inline bool Line_LinePoint::has_distance() const {
  return _has_bit(3);
}
inline void Line_LinePoint::clear_distance() {
  distance_ = 0;
  _clear_bit(3);
}
inline float Line_LinePoint::distance() const {
  return distance_;
}
inline void Line_LinePoint::set_distance(float value) {
  _set_bit(3);
  distance_ = value;
}

// required .bites.vision.Line.ScanDirection found_with_scan = 5;
inline bool Line_LinePoint::has_found_with_scan() const {
  return _has_bit(4);
}
inline void Line_LinePoint::clear_found_with_scan() {
  found_with_scan_ = 0;
  _clear_bit(4);
}
inline ::bites::vision::Line_ScanDirection Line_LinePoint::found_with_scan() const {
  return static_cast< ::bites::vision::Line_ScanDirection >(found_with_scan_);
}
inline void Line_LinePoint::set_found_with_scan(::bites::vision::Line_ScanDirection value) {
  GOOGLE_DCHECK(::bites::vision::Line_ScanDirection_IsValid(value));
  _set_bit(4);
  found_with_scan_ = value;
}

// -------------------------------------------------------------------

// Line

// required .bites.vision.Landmark self = 1;
inline bool Line::has_self() const {
  return _has_bit(0);
}
inline void Line::clear_self() {
  if (self_ != NULL) self_->::bites::vision::Landmark::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Landmark& Line::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::bites::vision::Landmark* Line::mutable_self() {
  _set_bit(0);
  if (self_ == NULL) self_ = new ::bites::vision::Landmark;
  return self_;
}

// repeated .bites.vision.Landmark possibles = 2;
inline int Line::possibles_size() const {
  return possibles_.size();
}
inline void Line::clear_possibles() {
  possibles_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >&
Line::possibles() const {
  return possibles_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >*
Line::mutable_possibles() {
  return &possibles_;
}
inline const ::bites::vision::Landmark& Line::possibles(int index) const {
  return possibles_.Get(index);
}
inline ::bites::vision::Landmark* Line::mutable_possibles(int index) {
  return possibles_.Mutable(index);
}
inline ::bites::vision::Landmark* Line::add_possibles() {
  return possibles_.Add();
}

// repeated .bites.vision.Line.LinePoint points = 3;
inline int Line::points_size() const {
  return points_.size();
}
inline void Line::clear_points() {
  points_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line_LinePoint >&
Line::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line_LinePoint >*
Line::mutable_points() {
  return &points_;
}
inline const ::bites::vision::Line_LinePoint& Line::points(int index) const {
  return points_.Get(index);
}
inline ::bites::vision::Line_LinePoint* Line::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::bites::vision::Line_LinePoint* Line::add_points() {
  return points_.Add();
}

// optional float angle = 4;
inline bool Line::has_angle() const {
  return _has_bit(3);
}
inline void Line::clear_angle() {
  angle_ = 0;
  _clear_bit(3);
}
inline float Line::angle() const {
  return angle_;
}
inline void Line::set_angle(float value) {
  _set_bit(3);
  angle_ = value;
}

// optional float a = 5;
inline bool Line::has_a() const {
  return _has_bit(4);
}
inline void Line::clear_a() {
  a_ = 0;
  _clear_bit(4);
}
inline float Line::a() const {
  return a_;
}
inline void Line::set_a(float value) {
  _set_bit(4);
  a_ = value;
}

// optional float b = 6;
inline bool Line::has_b() const {
  return _has_bit(5);
}
inline void Line::clear_b() {
  b_ = 0;
  _clear_bit(5);
}
inline float Line::b() const {
  return b_;
}
inline void Line::set_b(float value) {
  _set_bit(5);
  b_ = value;
}

// optional float length = 7;
inline bool Line::has_length() const {
  return _has_bit(6);
}
inline void Line::clear_length() {
  length_ = 0;
  _clear_bit(6);
}
inline float Line::length() const {
  return length_;
}
inline void Line::set_length(float value) {
  _set_bit(6);
  length_ = value;
}

// optional float avg_vertical_width = 8;
inline bool Line::has_avg_vertical_width() const {
  return _has_bit(7);
}
inline void Line::clear_avg_vertical_width() {
  avg_vertical_width_ = 0;
  _clear_bit(7);
}
inline float Line::avg_vertical_width() const {
  return avg_vertical_width_;
}
inline void Line::set_avg_vertical_width(float value) {
  _set_bit(7);
  avg_vertical_width_ = value;
}

// optional float avg_horizontal_width = 9;
inline bool Line::has_avg_horizontal_width() const {
  return _has_bit(8);
}
inline void Line::clear_avg_horizontal_width() {
  avg_horizontal_width_ = 0;
  _clear_bit(8);
}
inline float Line::avg_horizontal_width() const {
  return avg_horizontal_width_;
}
inline void Line::set_avg_horizontal_width(float value) {
  _set_bit(8);
  avg_horizontal_width_ = value;
}

// optional .bites.vision.Line.LinePoint thinnest_hor_point = 10;
inline bool Line::has_thinnest_hor_point() const {
  return _has_bit(9);
}
inline void Line::clear_thinnest_hor_point() {
  if (thinnest_hor_point_ != NULL) thinnest_hor_point_->::bites::vision::Line_LinePoint::Clear();
  _clear_bit(9);
}
inline const ::bites::vision::Line_LinePoint& Line::thinnest_hor_point() const {
  return thinnest_hor_point_ != NULL ? *thinnest_hor_point_ : *default_instance_->thinnest_hor_point_;
}
inline ::bites::vision::Line_LinePoint* Line::mutable_thinnest_hor_point() {
  _set_bit(9);
  if (thinnest_hor_point_ == NULL) thinnest_hor_point_ = new ::bites::vision::Line_LinePoint;
  return thinnest_hor_point_;
}

// optional .bites.vision.Line.LinePoint thickest_hor_point = 11;
inline bool Line::has_thickest_hor_point() const {
  return _has_bit(10);
}
inline void Line::clear_thickest_hor_point() {
  if (thickest_hor_point_ != NULL) thickest_hor_point_->::bites::vision::Line_LinePoint::Clear();
  _clear_bit(10);
}
inline const ::bites::vision::Line_LinePoint& Line::thickest_hor_point() const {
  return thickest_hor_point_ != NULL ? *thickest_hor_point_ : *default_instance_->thickest_hor_point_;
}
inline ::bites::vision::Line_LinePoint* Line::mutable_thickest_hor_point() {
  _set_bit(10);
  if (thickest_hor_point_ == NULL) thickest_hor_point_ = new ::bites::vision::Line_LinePoint;
  return thickest_hor_point_;
}

// optional .bites.vision.Line.LinePoint thinnest_vert_point = 12;
inline bool Line::has_thinnest_vert_point() const {
  return _has_bit(11);
}
inline void Line::clear_thinnest_vert_point() {
  if (thinnest_vert_point_ != NULL) thinnest_vert_point_->::bites::vision::Line_LinePoint::Clear();
  _clear_bit(11);
}
inline const ::bites::vision::Line_LinePoint& Line::thinnest_vert_point() const {
  return thinnest_vert_point_ != NULL ? *thinnest_vert_point_ : *default_instance_->thinnest_vert_point_;
}
inline ::bites::vision::Line_LinePoint* Line::mutable_thinnest_vert_point() {
  _set_bit(11);
  if (thinnest_vert_point_ == NULL) thinnest_vert_point_ = new ::bites::vision::Line_LinePoint;
  return thinnest_vert_point_;
}

// optional .bites.vision.Line.LinePoint thickest_vert_point = 13;
inline bool Line::has_thickest_vert_point() const {
  return _has_bit(12);
}
inline void Line::clear_thickest_vert_point() {
  if (thickest_vert_point_ != NULL) thickest_vert_point_->::bites::vision::Line_LinePoint::Clear();
  _clear_bit(12);
}
inline const ::bites::vision::Line_LinePoint& Line::thickest_vert_point() const {
  return thickest_vert_point_ != NULL ? *thickest_vert_point_ : *default_instance_->thickest_vert_point_;
}
inline ::bites::vision::Line_LinePoint* Line::mutable_thickest_vert_point() {
  _set_bit(12);
  if (thickest_vert_point_ == NULL) thickest_vert_point_ = new ::bites::vision::Line_LinePoint;
  return thickest_vert_point_;
}

// required .bites.vision.DistanceBearing db = 14;
inline bool Line::has_db() const {
  return _has_bit(13);
}
inline void Line::clear_db() {
  if (db_ != NULL) db_->::bites::vision::DistanceBearing::Clear();
  _clear_bit(13);
}
inline const ::bites::vision::DistanceBearing& Line::db() const {
  return db_ != NULL ? *db_ : *default_instance_->db_;
}
inline ::bites::vision::DistanceBearing* Line::mutable_db() {
  _set_bit(13);
  if (db_ == NULL) db_ = new ::bites::vision::DistanceBearing;
  return db_;
}

// required bool cc_line = 15;
inline bool Line::has_cc_line() const {
  return _has_bit(14);
}
inline void Line::clear_cc_line() {
  cc_line_ = false;
  _clear_bit(14);
}
inline bool Line::cc_line() const {
  return cc_line_;
}
inline void Line::set_cc_line(bool value) {
  _set_bit(14);
  cc_line_ = value;
}

// -------------------------------------------------------------------

// Corner

// required .bites.vision.Landmark self = 1;
inline bool Corner::has_self() const {
  return _has_bit(0);
}
inline void Corner::clear_self() {
  if (self_ != NULL) self_->::bites::vision::Landmark::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Landmark& Corner::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::bites::vision::Landmark* Corner::mutable_self() {
  _set_bit(0);
  if (self_ == NULL) self_ = new ::bites::vision::Landmark;
  return self_;
}

// required .bites.vision.Detection detect = 2;
inline bool Corner::has_detect() const {
  return _has_bit(1);
}
inline void Corner::clear_detect() {
  if (detect_ != NULL) detect_->::bites::vision::Detection::Clear();
  _clear_bit(1);
}
inline const ::bites::vision::Detection& Corner::detect() const {
  return detect_ != NULL ? *detect_ : *default_instance_->detect_;
}
inline ::bites::vision::Detection* Corner::mutable_detect() {
  _set_bit(1);
  if (detect_ == NULL) detect_ = new ::bites::vision::Detection;
  return detect_;
}

// repeated .bites.vision.Landmark possibles = 3;
inline int Corner::possibles_size() const {
  return possibles_.size();
}
inline void Corner::clear_possibles() {
  possibles_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >&
Corner::possibles() const {
  return possibles_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >*
Corner::mutable_possibles() {
  return &possibles_;
}
inline const ::bites::vision::Landmark& Corner::possibles(int index) const {
  return possibles_.Get(index);
}
inline ::bites::vision::Landmark* Corner::mutable_possibles(int index) {
  return possibles_.Mutable(index);
}
inline ::bites::vision::Landmark* Corner::add_possibles() {
  return possibles_.Add();
}

// repeated .bites.vision.Line lines = 4;
inline int Corner::lines_size() const {
  return lines_.size();
}
inline void Corner::clear_lines() {
  lines_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >&
Corner::lines() const {
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >*
Corner::mutable_lines() {
  return &lines_;
}
inline const ::bites::vision::Line& Corner::lines(int index) const {
  return lines_.Get(index);
}
inline ::bites::vision::Line* Corner::mutable_lines(int index) {
  return lines_.Mutable(index);
}
inline ::bites::vision::Line* Corner::add_lines() {
  return lines_.Add();
}

// repeated float dists = 5;
inline int Corner::dists_size() const {
  return dists_.size();
}
inline void Corner::clear_dists() {
  dists_.Clear();
}
inline const ::google::protobuf::RepeatedField< float >&
Corner::dists() const {
  return dists_;
}
inline ::google::protobuf::RepeatedField< float >*
Corner::mutable_dists() {
  return &dists_;
}
inline float Corner::dists(int index) const {
  return dists_.Get(index);
}
inline void Corner::set_dists(int index, float value) {
  dists_.Set(index, value);
}
inline void Corner::add_dists(float value) {
  dists_.Add(value);
}

// repeated .bites.vision.Line t_lines = 6;
inline int Corner::t_lines_size() const {
  return t_lines_.size();
}
inline void Corner::clear_t_lines() {
  t_lines_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >&
Corner::t_lines() const {
  return t_lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >*
Corner::mutable_t_lines() {
  return &t_lines_;
}
inline const ::bites::vision::Line& Corner::t_lines(int index) const {
  return t_lines_.Get(index);
}
inline ::bites::vision::Line* Corner::mutable_t_lines(int index) {
  return t_lines_.Mutable(index);
}
inline ::bites::vision::Line* Corner::add_t_lines() {
  return t_lines_.Add();
}

// required float angle_between_lines = 7;
inline bool Corner::has_angle_between_lines() const {
  return _has_bit(6);
}
inline void Corner::clear_angle_between_lines() {
  angle_between_lines_ = 0;
  _clear_bit(6);
}
inline float Corner::angle_between_lines() const {
  return angle_between_lines_;
}
inline void Corner::set_angle_between_lines(float value) {
  _set_bit(6);
  angle_between_lines_ = value;
}

// -------------------------------------------------------------------

// Cross

// required .bites.vision.Landmark self = 1;
inline bool Cross::has_self() const {
  return _has_bit(0);
}
inline void Cross::clear_self() {
  if (self_ != NULL) self_->::bites::vision::Landmark::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Landmark& Cross::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::bites::vision::Landmark* Cross::mutable_self() {
  _set_bit(0);
  if (self_ == NULL) self_ = new ::bites::vision::Landmark;
  return self_;
}

// required .bites.vision.Detection detect = 2;
inline bool Cross::has_detect() const {
  return _has_bit(1);
}
inline void Cross::clear_detect() {
  if (detect_ != NULL) detect_->::bites::vision::Detection::Clear();
  _clear_bit(1);
}
inline const ::bites::vision::Detection& Cross::detect() const {
  return detect_ != NULL ? *detect_ : *default_instance_->detect_;
}
inline ::bites::vision::Detection* Cross::mutable_detect() {
  _set_bit(1);
  if (detect_ == NULL) detect_ = new ::bites::vision::Detection;
  return detect_;
}

// repeated .bites.vision.Landmark possibles = 3;
inline int Cross::possibles_size() const {
  return possibles_.size();
}
inline void Cross::clear_possibles() {
  possibles_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >&
Cross::possibles() const {
  return possibles_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Landmark >*
Cross::mutable_possibles() {
  return &possibles_;
}
inline const ::bites::vision::Landmark& Cross::possibles(int index) const {
  return possibles_.Get(index);
}
inline ::bites::vision::Landmark* Cross::mutable_possibles(int index) {
  return possibles_.Mutable(index);
}
inline ::bites::vision::Landmark* Cross::add_possibles() {
  return possibles_.Add();
}

// required .bites.Rectangle bounds = 4;
inline bool Cross::has_bounds() const {
  return _has_bit(3);
}
inline void Cross::clear_bounds() {
  if (bounds_ != NULL) bounds_->::bites::Rectangle::Clear();
  _clear_bit(3);
}
inline const ::bites::Rectangle& Cross::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::bites::Rectangle* Cross::mutable_bounds() {
  _set_bit(3);
  if (bounds_ == NULL) bounds_ = new ::bites::Rectangle;
  return bounds_;
}

// -------------------------------------------------------------------

// CrossBar

// required .bites.vision.Detection detect = 1;
inline bool CrossBar::has_detect() const {
  return _has_bit(0);
}
inline void CrossBar::clear_detect() {
  if (detect_ != NULL) detect_->::bites::vision::Detection::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Detection& CrossBar::detect() const {
  return detect_ != NULL ? *detect_ : *default_instance_->detect_;
}
inline ::bites::vision::Detection* CrossBar::mutable_detect() {
  _set_bit(0);
  if (detect_ == NULL) detect_ = new ::bites::vision::Detection;
  return detect_;
}

// required .bites.Rectangle bounds = 2;
inline bool CrossBar::has_bounds() const {
  return _has_bit(1);
}
inline void CrossBar::clear_bounds() {
  if (bounds_ != NULL) bounds_->::bites::Rectangle::Clear();
  _clear_bit(1);
}
inline const ::bites::Rectangle& CrossBar::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::bites::Rectangle* CrossBar::mutable_bounds() {
  _set_bit(1);
  if (bounds_ == NULL) bounds_ = new ::bites::Rectangle;
  return bounds_;
}

// -------------------------------------------------------------------

// FieldObject

// required .bites.vision.Landmark self = 1;
inline bool FieldObject::has_self() const {
  return _has_bit(0);
}
inline void FieldObject::clear_self() {
  if (self_ != NULL) self_->::bites::vision::Landmark::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Landmark& FieldObject::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::bites::vision::Landmark* FieldObject::mutable_self() {
  _set_bit(0);
  if (self_ == NULL) self_ = new ::bites::vision::Landmark;
  return self_;
}

// required .bites.vision.Landmark possibles = 2;
inline bool FieldObject::has_possibles() const {
  return _has_bit(1);
}
inline void FieldObject::clear_possibles() {
  if (possibles_ != NULL) possibles_->::bites::vision::Landmark::Clear();
  _clear_bit(1);
}
inline const ::bites::vision::Landmark& FieldObject::possibles() const {
  return possibles_ != NULL ? *possibles_ : *default_instance_->possibles_;
}
inline ::bites::vision::Landmark* FieldObject::mutable_possibles() {
  _set_bit(1);
  if (possibles_ == NULL) possibles_ = new ::bites::vision::Landmark;
  return possibles_;
}

// required .bites.Rectangle bounds = 3;
inline bool FieldObject::has_bounds() const {
  return _has_bit(2);
}
inline void FieldObject::clear_bounds() {
  if (bounds_ != NULL) bounds_->::bites::Rectangle::Clear();
  _clear_bit(2);
}
inline const ::bites::Rectangle& FieldObject::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::bites::Rectangle* FieldObject::mutable_bounds() {
  _set_bit(2);
  if (bounds_ == NULL) bounds_ = new ::bites::Rectangle;
  return bounds_;
}

// -------------------------------------------------------------------

// Robot

// required .bites.vision.Detection detect = 1;
inline bool Robot::has_detect() const {
  return _has_bit(0);
}
inline void Robot::clear_detect() {
  if (detect_ != NULL) detect_->::bites::vision::Detection::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Detection& Robot::detect() const {
  return detect_ != NULL ? *detect_ : *default_instance_->detect_;
}
inline ::bites::vision::Detection* Robot::mutable_detect() {
  _set_bit(0);
  if (detect_ == NULL) detect_ = new ::bites::vision::Detection;
  return detect_;
}

// required .bites.Rectangle bounds = 2;
inline bool Robot::has_bounds() const {
  return _has_bit(1);
}
inline void Robot::clear_bounds() {
  if (bounds_ != NULL) bounds_->::bites::Rectangle::Clear();
  _clear_bit(1);
}
inline const ::bites::Rectangle& Robot::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::bites::Rectangle* Robot::mutable_bounds() {
  _set_bit(1);
  if (bounds_ == NULL) bounds_ = new ::bites::Rectangle;
  return bounds_;
}

// required int32 back_left = 3;
inline bool Robot::has_back_left() const {
  return _has_bit(2);
}
inline void Robot::clear_back_left() {
  back_left_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Robot::back_left() const {
  return back_left_;
}
inline void Robot::set_back_left(::google::protobuf::int32 value) {
  _set_bit(2);
  back_left_ = value;
}

// required int32 back_right = 4;
inline bool Robot::has_back_right() const {
  return _has_bit(3);
}
inline void Robot::clear_back_right() {
  back_right_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Robot::back_right() const {
  return back_right_;
}
inline void Robot::set_back_right(::google::protobuf::int32 value) {
  _set_bit(3);
  back_right_ = value;
}

// required int32 back_dir = 5;
inline bool Robot::has_back_dir() const {
  return _has_bit(4);
}
inline void Robot::clear_back_dir() {
  back_dir_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Robot::back_dir() const {
  return back_dir_;
}
inline void Robot::set_back_dir(::google::protobuf::int32 value) {
  _set_bit(4);
  back_dir_ = value;
}

// -------------------------------------------------------------------

// Ball

// required .bites.vision.Detection detect = 1;
inline bool Ball::has_detect() const {
  return _has_bit(0);
}
inline void Ball::clear_detect() {
  if (detect_ != NULL) detect_->::bites::vision::Detection::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Detection& Ball::detect() const {
  return detect_ != NULL ? *detect_ : *default_instance_->detect_;
}
inline ::bites::vision::Detection* Ball::mutable_detect() {
  _set_bit(0);
  if (detect_ == NULL) detect_ = new ::bites::vision::Detection;
  return detect_;
}

// required float radius = 2;
inline bool Ball::has_radius() const {
  return _has_bit(1);
}
inline void Ball::clear_radius() {
  radius_ = 0;
  _clear_bit(1);
}
inline float Ball::radius() const {
  return radius_;
}
inline void Ball::set_radius(float value) {
  _set_bit(1);
  radius_ = value;
}

// required int32 confidence = 3;
inline bool Ball::has_confidence() const {
  return _has_bit(2);
}
inline void Ball::clear_confidence() {
  confidence_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Ball::confidence() const {
  return confidence_;
}
inline void Ball::set_confidence(::google::protobuf::int32 value) {
  _set_bit(2);
  confidence_ = value;
}

// -------------------------------------------------------------------

// Frame

// optional .bites.vision.Image image = 1;
inline bool Frame::has_image() const {
  return _has_bit(0);
}
inline void Frame::clear_image() {
  if (image_ != NULL) image_->::bites::vision::Image::Clear();
  _clear_bit(0);
}
inline const ::bites::vision::Image& Frame::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::bites::vision::Image* Frame::mutable_image() {
  _set_bit(0);
  if (image_ == NULL) image_ = new ::bites::vision::Image;
  return image_;
}

// repeated .bites.vision.Ball balls = 2;
inline int Frame::balls_size() const {
  return balls_.size();
}
inline void Frame::clear_balls() {
  balls_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Ball >&
Frame::balls() const {
  return balls_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Ball >*
Frame::mutable_balls() {
  return &balls_;
}
inline const ::bites::vision::Ball& Frame::balls(int index) const {
  return balls_.Get(index);
}
inline ::bites::vision::Ball* Frame::mutable_balls(int index) {
  return balls_.Mutable(index);
}
inline ::bites::vision::Ball* Frame::add_balls() {
  return balls_.Add();
}

// repeated .bites.vision.FieldObject objects = 3;
inline int Frame::objects_size() const {
  return objects_.size();
}
inline void Frame::clear_objects() {
  objects_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::FieldObject >&
Frame::objects() const {
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::FieldObject >*
Frame::mutable_objects() {
  return &objects_;
}
inline const ::bites::vision::FieldObject& Frame::objects(int index) const {
  return objects_.Get(index);
}
inline ::bites::vision::FieldObject* Frame::mutable_objects(int index) {
  return objects_.Mutable(index);
}
inline ::bites::vision::FieldObject* Frame::add_objects() {
  return objects_.Add();
}

// repeated .bites.vision.Line lines = 4;
inline int Frame::lines_size() const {
  return lines_.size();
}
inline void Frame::clear_lines() {
  lines_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >&
Frame::lines() const {
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Line >*
Frame::mutable_lines() {
  return &lines_;
}
inline const ::bites::vision::Line& Frame::lines(int index) const {
  return lines_.Get(index);
}
inline ::bites::vision::Line* Frame::mutable_lines(int index) {
  return lines_.Mutable(index);
}
inline ::bites::vision::Line* Frame::add_lines() {
  return lines_.Add();
}

// repeated .bites.vision.Corner corners = 5;
inline int Frame::corners_size() const {
  return corners_.size();
}
inline void Frame::clear_corners() {
  corners_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Corner >&
Frame::corners() const {
  return corners_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Corner >*
Frame::mutable_corners() {
  return &corners_;
}
inline const ::bites::vision::Corner& Frame::corners(int index) const {
  return corners_.Get(index);
}
inline ::bites::vision::Corner* Frame::mutable_corners(int index) {
  return corners_.Mutable(index);
}
inline ::bites::vision::Corner* Frame::add_corners() {
  return corners_.Add();
}

// repeated .bites.vision.Robot robots = 6;
inline int Frame::robots_size() const {
  return robots_.size();
}
inline void Frame::clear_robots() {
  robots_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::bites::vision::Robot >&
Frame::robots() const {
  return robots_;
}
inline ::google::protobuf::RepeatedPtrField< ::bites::vision::Robot >*
Frame::mutable_robots() {
  return &robots_;
}
inline const ::bites::vision::Robot& Frame::robots(int index) const {
  return robots_.Get(index);
}
inline ::bites::vision::Robot* Frame::mutable_robots(int index) {
  return robots_.Mutable(index);
}
inline ::bites::vision::Robot* Frame::add_robots() {
  return robots_.Add();
}


}  // namespace vision
}  // namespace bites
#endif  // PROTOBUF_vision_2eproto__INCLUDED
