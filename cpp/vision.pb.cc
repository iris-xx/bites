// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "vision.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format_inl.h>

namespace man {
namespace vision {

namespace {

const ::google::protobuf::Descriptor* Image_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Image_Encoding_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Landmark_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Landmark_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Landmark_ID_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Landmark_IDCertainty_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Landmark_DistanceCertainty_descriptor_ = NULL;
const ::google::protobuf::Descriptor* DistanceBearing_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DistanceBearing_reflection_ = NULL;
const ::google::protobuf::Descriptor* Detection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Detection_reflection_ = NULL;
const ::google::protobuf::Descriptor* Line_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Line_reflection_ = NULL;
const ::google::protobuf::Descriptor* Line_LinePoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Line_LinePoint_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Line_ScanDirection_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Corner_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Corner_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Corner_Shape_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Cross_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Cross_reflection_ = NULL;
const ::google::protobuf::Descriptor* CrossBar_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CrossBar_reflection_ = NULL;
const ::google::protobuf::Descriptor* FieldObject_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FieldObject_reflection_ = NULL;
const ::google::protobuf::Descriptor* Robot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Robot_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ball_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ball_reflection_ = NULL;
const ::google::protobuf::Descriptor* Frame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Frame_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_vision_2eproto() {
  protobuf_AddDesc_vision_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "vision.proto");
  GOOGLE_CHECK(file != NULL);
  Image_descriptor_ = file->message_type(0);
  static const int Image_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, encoding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, data_),
  };
  Image_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Image_descriptor_,
      Image::default_instance_,
      Image_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Image));
  Image_Encoding_descriptor_ = Image_descriptor_->enum_type(0);
  Landmark_descriptor_ = file->message_type(1);
  static const int Landmark_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, field_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, field_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, id_certainty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, distance_certainty_),
  };
  Landmark_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Landmark_descriptor_,
      Landmark::default_instance_,
      Landmark_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, _extensions_),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Landmark));
  Landmark_ID_descriptor_ = Landmark_descriptor_->enum_type(0);
  Landmark_IDCertainty_descriptor_ = Landmark_descriptor_->enum_type(1);
  Landmark_DistanceCertainty_descriptor_ = Landmark_descriptor_->enum_type(2);
  DistanceBearing_descriptor_ = file->message_type(2);
  static const int DistanceBearing_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistanceBearing, distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistanceBearing, bearing_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistanceBearing, distance_sd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistanceBearing, bearing_sd_),
  };
  DistanceBearing_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DistanceBearing_descriptor_,
      DistanceBearing::default_instance_,
      DistanceBearing_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistanceBearing, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistanceBearing, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DistanceBearing));
  Detection_descriptor_ = file->message_type(3);
  static const int Detection_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, center_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, center_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, angle_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, angle_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, foc_dist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, elevation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, db_),
  };
  Detection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Detection_descriptor_,
      Detection::default_instance_,
      Detection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Detection, _extensions_),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Detection));
  Line_descriptor_ = file->message_type(4);
  static const int Line_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, self_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, possibles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, points_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, a_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, b_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, avg_vertical_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, avg_horizontal_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, thinnest_hor_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, thickest_hor_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, thinnest_vert_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, thickest_vert_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, db_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, cc_line_),
  };
  Line_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Line_descriptor_,
      Line::default_instance_,
      Line_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Line));
  Line_LinePoint_descriptor_ = Line_descriptor_->nested_type(0);
  static const int Line_LinePoint_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line_LinePoint, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line_LinePoint, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line_LinePoint, line_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line_LinePoint, distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line_LinePoint, found_with_scan_),
  };
  Line_LinePoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Line_LinePoint_descriptor_,
      Line_LinePoint::default_instance_,
      Line_LinePoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line_LinePoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line_LinePoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Line_LinePoint));
  Line_ScanDirection_descriptor_ = Line_descriptor_->enum_type(0);
  Corner_descriptor_ = file->message_type(5);
  static const int Corner_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, self_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, detect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, possibles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, lines_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, dists_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, t_lines_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, angle_between_lines_),
  };
  Corner_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Corner_descriptor_,
      Corner::default_instance_,
      Corner_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corner, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Corner));
  Corner_Shape_descriptor_ = Corner_descriptor_->enum_type(0);
  Cross_descriptor_ = file->message_type(6);
  static const int Cross_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cross, self_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cross, detect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cross, possibles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cross, bounds_),
  };
  Cross_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Cross_descriptor_,
      Cross::default_instance_,
      Cross_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cross, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cross, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Cross));
  CrossBar_descriptor_ = file->message_type(7);
  static const int CrossBar_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossBar, detect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossBar, bounds_),
  };
  CrossBar_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CrossBar_descriptor_,
      CrossBar::default_instance_,
      CrossBar_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossBar, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossBar, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CrossBar));
  FieldObject_descriptor_ = file->message_type(8);
  static const int FieldObject_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldObject, self_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldObject, possibles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldObject, bounds_),
  };
  FieldObject_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FieldObject_descriptor_,
      FieldObject::default_instance_,
      FieldObject_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldObject, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldObject, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FieldObject));
  Robot_descriptor_ = file->message_type(9);
  static const int Robot_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, detect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, bounds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, back_left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, back_right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, back_dir_),
  };
  Robot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Robot_descriptor_,
      Robot::default_instance_,
      Robot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Robot));
  Ball_descriptor_ = file->message_type(10);
  static const int Ball_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ball, detect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ball, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ball, confidence_),
  };
  Ball_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ball_descriptor_,
      Ball::default_instance_,
      Ball_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ball, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ball, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ball));
  Frame_descriptor_ = file->message_type(11);
  static const int Frame_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, balls_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, objects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, lines_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, corners_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, robots_),
  };
  Frame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Frame_descriptor_,
      Frame::default_instance_,
      Frame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Frame));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_vision_2eproto);
}

void protobuf_RegisterTypes() {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Image_descriptor_, &Image::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Landmark_descriptor_, &Landmark::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DistanceBearing_descriptor_, &DistanceBearing::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Detection_descriptor_, &Detection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Line_descriptor_, &Line::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Line_LinePoint_descriptor_, &Line_LinePoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Corner_descriptor_, &Corner::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Cross_descriptor_, &Cross::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CrossBar_descriptor_, &CrossBar::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FieldObject_descriptor_, &FieldObject::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Robot_descriptor_, &Robot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ball_descriptor_, &Ball::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Frame_descriptor_, &Frame::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_vision_2eproto() {
  delete Image::default_instance_;
  delete Image_reflection_;
  delete Landmark::default_instance_;
  delete Landmark_reflection_;
  delete DistanceBearing::default_instance_;
  delete DistanceBearing_reflection_;
  delete Detection::default_instance_;
  delete Detection_reflection_;
  delete Line::default_instance_;
  delete Line_reflection_;
  delete Line_LinePoint::default_instance_;
  delete Line_LinePoint_reflection_;
  delete Corner::default_instance_;
  delete Corner_reflection_;
  delete Cross::default_instance_;
  delete Cross_reflection_;
  delete CrossBar::default_instance_;
  delete CrossBar_reflection_;
  delete FieldObject::default_instance_;
  delete FieldObject_reflection_;
  delete Robot::default_instance_;
  delete Robot_reflection_;
  delete Ball::default_instance_;
  delete Ball_reflection_;
  delete Frame::default_instance_;
  delete Frame_reflection_;
}

void protobuf_AddDesc_vision_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::man::protobuf_AddDesc_structs_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014vision.proto\022\nman.vision\032\rstructs.prot"
    "o\"\237\001\n\005Image\0224\n\010encoding\030\001 \002(\0162\032.man.visi"
    "on.Image.Encoding:\006YUV422\022\r\n\005width\030\002 \002(\005"
    "\022\016\n\006height\030\003 \002(\005\022\014\n\004data\030\004 \002(\014\"3\n\010Encodi"
    "ng\022\t\n\005YCbCr\020\001\022\n\n\006YUV422\020\002\022\007\n\003RGB\020\003\022\007\n\003BM"
    "P\020\004\"\232\016\n\010Landmark\022#\n\002id\030\001 \002(\0162\027.man.visio"
    "n.Landmark.ID\022\017\n\007field_x\030\002 \002(\002\022\017\n\007field_"
    "y\030\003 \002(\002\0226\n\014id_certainty\030\004 \001(\0162 .man.visi"
    "on.Landmark.IDCertainty\022B\n\022distance_cert"
    "ainty\030\005 \001(\0162&.man.vision.Landmark.Distan"
    "ceCertainty\"\262\013\n\002ID\022\022\n\016L_INNER_CORNER\020\000\022\022"
    "\n\016L_OUTER_CORNER\020\001\022\014\n\010T_CORNER\020\002\022\021\n\rCENT"
    "ER_CIRCLE\020\003\022\017\n\013BLUE_GOAL_T\020\004\022\021\n\rYELLOW_G"
    "OAL_T\020\005\022+\n\'BLUE_GOAL_RIGHT_L_OR_YELLOW_G"
    "OAL_LEFT_L\020\006\022+\n\'BLUE_GOAL_LEFT_L_OR_YELL"
    "OW_GOAL_RIGHT_L\020\007\022/\n+BLUE_CORNER_TOP_L_O"
    "R_YELLOW_CORNER_BOTTOM_L\020\010\022/\n+BLUE_CORNE"
    "R_BOTTOM_L_OR_YELLOW_CORNER_TOP_L\020\t\022\022\n\016C"
    "ORNER_INNER_L\020\n\022\024\n\020GOAL_BOX_INNER_L\020\013\022\025\n"
    "\021BLUE_GOAL_OUTER_L\020\014\022\027\n\023YELLOW_GOAL_OUTE"
    "R_L\020\r\022\014\n\010CENTER_T\020\016\022\025\n\021BLUE_CORNER_TOP_L"
    "\020\017\022\030\n\024BLUE_CORNER_BOTTOM_L\020\020\022\024\n\020BLUE_GOA"
    "L_LEFT_T\020\021\022\025\n\021BLUE_GOAL_RIGHT_T\020\022\022\024\n\020BLU"
    "E_GOAL_LEFT_L\020\023\022\025\n\021BLUE_GOAL_RIGHT_L\020\024\022\023"
    "\n\017CENTER_BOTTOM_T\020\025\022\020\n\014CENTER_TOP_T\020\026\022\032\n"
    "\026YELLOW_CORNER_BOTTOM_L\020\027\022\027\n\023YELLOW_CORN"
    "ER_TOP_L\020\030\022\026\n\022YELLOW_GOAL_LEFT_T\020\031\022\027\n\023YE"
    "LLOW_GOAL_RIGHT_T\020\032\022\026\n\022YELLOW_GOAL_LEFT_"
    "L\020\033\022\027\n\023YELLOW_GOAL_RIGHT_L\020\034\022\025\n\021CORNER_N"
    "O_IDEA_ID\020\035\022\n\n\006TOP_CC\020\036\022\r\n\tBOTTOM_CC\020\037\022\027"
    "\n\023BLUE_GOAL_LEFT_POST\020(\022\030\n\024BLUE_GOAL_RIG"
    "HT_POST\020)\022\031\n\025YELLOW_GOAL_LEFT_POST\020*\022\032\n\026"
    "YELLOW_GOAL_RIGHT_POST\020+\022\022\n\016BLUE_GOAL_PO"
    "ST\020,\022\024\n\020YELLOW_GOAL_POST\020-\022\030\n\024UNKNOWN_FI"
    "ELD_OBJECT\020.\022\020\n\014UNKNOWN_LINE\0202\022\023\n\017SIDE_O"
    "R_ENDLINE\0203\022\021\n\rSIDELINE_LINE\0204\022\020\n\014ENDLIN"
    "E_LINE\0205\022\020\n\014GOALBOX_LINE\0206\022\025\n\021GOALBOX_SI"
    "DE_LINE\0207\022\024\n\020GOALBOX_TOP_LINE\0208\022\025\n\021BLUE_"
    "GOAL_ENDLINE\0209\022\027\n\023YELLOW_GOAL_ENDLINE\020:\022"
    "\030\n\024BLUE_YELLOW_SIDELINE\020;\022\030\n\024YELLOW_BLUE"
    "_SIDELINE\020<\022\025\n\021CENTER_FIELD_LINE\020=\022\031\n\025BL"
    "UE_GOALBOX_TOP_LINE\020>\022\032\n\026BLUE_GOALBOX_LE"
    "FT_LINE\020?\022\033\n\027BLUE_GOALBOX_RIGHT_LINE\020@\022\033"
    "\n\027YELLOW_GOALBOX_TOP_LINE\020A\022\034\n\030YELLOW_GO"
    "ALBOX_LEFT_LINE\020A\022\035\n\031YELLOW_GOALBOX_RIGH"
    "T_LINE\020B\022\023\n\017BLUE_GOAL_CROSS\020P\022\025\n\021YELLOW_"
    "GOAL_CROSS\020Q\022\022\n\016ABSTRACT_CROSS\020R\"6\n\013IDCe"
    "rtainty\022\014\n\010NOT_SURE\020\000\022\016\n\nMILDY_SURE\020\001\022\t\n"
    "\005_SURE\020\002\"X\n\021DistanceCertainty\022\017\n\013BOTH_UN"
    "SURE\020\000\022\020\n\014WIDTH_UNSURE\020\001\022\021\n\rHEIGHT_UNSUR"
    "E\020\002\022\r\n\tBOTH_SURE\020\003*\004\010\n\020e\"]\n\017DistanceBear"
    "ing\022\020\n\010distance\030\001 \002(\002\022\017\n\007bearing\030\002 \002(\002\022\023"
    "\n\013distance_sd\030\003 \002(\002\022\022\n\nbearing_sd\030\004 \002(\002\""
    "\333\001\n\tDetection\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\022\r\n\005w"
    "idth\030\003 \002(\002\022\016\n\006height\030\004 \002(\002\022\020\n\010center_x\030\005"
    " \002(\005\022\020\n\010center_y\030\006 \002(\005\022\017\n\007angle_x\030\007 \002(\002\022"
    "\017\n\007angle_y\030\010 \002(\002\022\020\n\010foc_dist\030\t \002(\002\022\021\n\tel"
    "evation\030\n \002(\002\022\'\n\002db\030\013 \002(\0132\033.man.vision.D"
    "istanceBearing*\005\010\024\020\311\001\"\214\006\n\004Line\022\"\n\004self\030\001"
    " \002(\0132\024.man.vision.Landmark\022\'\n\tpossibles\030"
    "\002 \003(\0132\024.man.vision.Landmark\022*\n\006points\030\003 "
    "\003(\0132\032.man.vision.Line.LinePoint\022\r\n\005angle"
    "\030\004 \001(\002\022\t\n\001a\030\005 \001(\002\022\t\n\001b\030\006 \001(\002\022\016\n\006length\030\007"
    " \001(\002\022\032\n\022avg_vertical_width\030\010 \001(\002\022\034\n\024avg_"
    "horizontal_width\030\t \001(\002\0226\n\022thinnest_hor_p"
    "oint\030\n \001(\0132\032.man.vision.Line.LinePoint\0226"
    "\n\022thickest_hor_point\030\013 \001(\0132\032.man.vision."
    "Line.LinePoint\0227\n\023thinnest_vert_point\030\014 "
    "\001(\0132\032.man.vision.Line.LinePoint\0227\n\023thick"
    "est_vert_point\030\r \001(\0132\032.man.vision.Line.L"
    "inePoint\022\'\n\002db\030\016 \002(\0132\033.man.vision.Distan"
    "ceBearing\022\017\n\007cc_line\030\017 \002(\010\032\200\001\n\tLinePoint"
    "\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\022\022\n\nline_width\030\003 \002"
    "(\002\022\020\n\010distance\030\004 \002(\002\0227\n\017found_with_scan\030"
    "\005 \002(\0162\036.man.vision.Line.ScanDirection\"-\n"
    "\rScanDirection\022\016\n\nHORIZONTAL\020\000\022\014\n\010VERTIC"
    "AL\020\0012&\n\010field_x2\022\024.man.vision.Landmark\030\n"
    " \001(\0022&\n\010field_y2\022\024.man.vision.Landmark\030\013"
    " \001(\002\"\266\003\n\006Corner\022\"\n\004self\030\001 \002(\0132\024.man.visi"
    "on.Landmark\022%\n\006detect\030\002 \002(\0132\025.man.vision"
    ".Detection\022\'\n\tpossibles\030\003 \003(\0132\024.man.visi"
    "on.Landmark\022\037\n\005lines\030\004 \003(\0132\020.man.vision."
    "Line\022\r\n\005dists\030\005 \003(\002\022!\n\007t_lines\030\006 \003(\0132\020.m"
    "an.vision.Line\022\033\n\023angle_between_lines\030\007 "
    "\002(\002\"A\n\005Shape\022\013\n\007INNER_L\020\000\022\013\n\007OUTER_L\020\001\022\005"
    "\n\001T\020\002\022\n\n\006CIRCLE\020\003\022\013\n\007UNKNOWN\020\0042C\n\013corner"
    "_type\022\024.man.vision.Landmark\030\014 \001(\0162\030.man."
    "vision.Corner.Shape2@\n\014corner_lines\022\024.ma"
    "n.vision.Landmark\030\r \003(\0132\024.man.vision.Lan"
    "dmark\"\233\001\n\005Cross\022\"\n\004self\030\001 \002(\0132\024.man.visi"
    "on.Landmark\022%\n\006detect\030\002 \002(\0132\025.man.vision"
    ".Detection\022\'\n\tpossibles\030\003 \003(\0132\024.man.visi"
    "on.Landmark\022\036\n\006bounds\030\004 \002(\0132\016.man.Rectan"
    "gle\"Q\n\010CrossBar\022%\n\006detect\030\001 \002(\0132\025.man.vi"
    "sion.Detection\022\036\n\006bounds\030\002 \002(\0132\016.man.Rec"
    "tangle\"z\n\013FieldObject\022\"\n\004self\030\001 \002(\0132\024.ma"
    "n.vision.Landmark\022\'\n\tpossibles\030\002 \002(\0132\024.m"
    "an.vision.Landmark\022\036\n\006bounds\030\003 \002(\0132\016.man"
    ".Rectangle\"\207\001\n\005Robot\022%\n\006detect\030\001 \002(\0132\025.m"
    "an.vision.Detection\022\036\n\006bounds\030\002 \002(\0132\016.ma"
    "n.Rectangle\022\021\n\tback_left\030\003 \002(\005\022\022\n\nback_r"
    "ight\030\004 \002(\005\022\020\n\010back_dir\030\005 \002(\005\"Q\n\004Ball\022%\n\006"
    "detect\030\001 \002(\0132\025.man.vision.Detection\022\016\n\006r"
    "adius\030\002 \002(\002\022\022\n\nconfidence\030\003 \002(\005\"\335\001\n\005Fram"
    "e\022 \n\005image\030\001 \001(\0132\021.man.vision.Image\022\037\n\005b"
    "alls\030\002 \003(\0132\020.man.vision.Ball\022(\n\007objects\030"
    "\003 \003(\0132\027.man.vision.FieldObject\022\037\n\005lines\030"
    "\004 \003(\0132\020.man.vision.Line\022#\n\007corners\030\005 \003(\013"
    "2\022.man.vision.Corner\022!\n\006robots\030\006 \003(\0132\021.m"
    "an.vision.Robot", 4375);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "vision.proto", &protobuf_RegisterTypes);
  Image::default_instance_ = new Image();
  Landmark::default_instance_ = new Landmark();
  DistanceBearing::default_instance_ = new DistanceBearing();
  Detection::default_instance_ = new Detection();
  Line::default_instance_ = new Line();
  Line_LinePoint::default_instance_ = new Line_LinePoint();
  Corner::default_instance_ = new Corner();
  Cross::default_instance_ = new Cross();
  CrossBar::default_instance_ = new CrossBar();
  FieldObject::default_instance_ = new FieldObject();
  Robot::default_instance_ = new Robot();
  Ball::default_instance_ = new Ball();
  Frame::default_instance_ = new Frame();
  Image::default_instance_->InitAsDefaultInstance();
  Landmark::default_instance_->InitAsDefaultInstance();
  DistanceBearing::default_instance_->InitAsDefaultInstance();
  Detection::default_instance_->InitAsDefaultInstance();
  Line::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterExtension(
    &::man::vision::Landmark::default_instance(),
    10, 2, false, false);
  ::google::protobuf::internal::ExtensionSet::RegisterExtension(
    &::man::vision::Landmark::default_instance(),
    11, 2, false, false);
  Line_LinePoint::default_instance_->InitAsDefaultInstance();
  Corner::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterEnumExtension(
    &::man::vision::Landmark::default_instance(),
    12, 14, false, false,
    &::man::vision::Corner_Shape_IsValid);
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::man::vision::Landmark::default_instance(),
    13, 11, true, false,
    &::man::vision::Landmark::default_instance());
  Cross::default_instance_->InitAsDefaultInstance();
  CrossBar::default_instance_->InitAsDefaultInstance();
  FieldObject::default_instance_->InitAsDefaultInstance();
  Robot::default_instance_->InitAsDefaultInstance();
  Ball::default_instance_->InitAsDefaultInstance();
  Frame::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_vision_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_vision_2eproto {
  StaticDescriptorInitializer_vision_2eproto() {
    protobuf_AddDesc_vision_2eproto();
  }
} static_descriptor_initializer_vision_2eproto_;


// ===================================================================

const ::google::protobuf::EnumDescriptor* Image_Encoding_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_Encoding_descriptor_;
}
bool Image_Encoding_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Image_Encoding Image::YCbCr;
const Image_Encoding Image::YUV422;
const Image_Encoding Image::RGB;
const Image_Encoding Image::BMP;
const Image_Encoding Image::Encoding_MIN;
const Image_Encoding Image::Encoding_MAX;
#endif  // _MSC_VER
const ::std::string Image::_default_data_;
#ifndef _MSC_VER
const int Image::kEncodingFieldNumber;
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kDataFieldNumber;
#endif  // !_MSC_VER

Image::Image()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Image::InitAsDefaultInstance() {}

Image::Image(const Image& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Image::SharedCtor() {
  _cached_size_ = 0;
  encoding_ = 2;
  width_ = 0;
  height_ = 0;
  data_ = const_cast< ::std::string*>(&_default_data_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  SharedDtor();
}

void Image::SharedDtor() {
  if (data_ != &_default_data_) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_descriptor_;
}

const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New() const {
  return new Image;
}

void Image::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    encoding_ = 2;
    width_ = 0;
    height_ = 0;
    if (_has_bit(3)) {
      if (data_ != &_default_data_) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Image.Encoding encoding = 1 [default = YUV422];
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (::man::vision::Image_Encoding_IsValid(value)) {
          set_encoding(static_cast< ::man::vision::Image_Encoding >(value));
        } else {
          mutable_unknown_fields()->AddVarint(1, value);
        }
        if (input->ExpectTag(16)) goto parse_width;
        break;
      }
      
      // required int32 width = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_width:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &width_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_height;
        break;
      }
      
      // required int32 height = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_height:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &height_));
        _set_bit(2);
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }
      
      // required bytes data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_data:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_data()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Image::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Image.Encoding encoding = 1 [default = YUV422];
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(1, this->encoding(), output);
  }
  
  // required int32 width = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(2, this->width(), output);
  }
  
  // required int32 height = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(3, this->height(), output);
  }
  
  // required bytes data = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->data(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Image::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Image.Encoding encoding = 1 [default = YUV422];
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(1, this->encoding(), target);
  }
  
  // required int32 width = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(2, this->width(), target);
  }
  
  // required int32 height = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(3, this->height(), target);
  }
  
  // required bytes data = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->data(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Image::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Image.Encoding encoding = 1 [default = YUV422];
    if (has_encoding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->encoding());
    }
    
    // required int32 width = 2;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->width());
    }
    
    // required int32 height = 3;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->height());
    }
    
    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->data());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Image* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Image*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_encoding(from.encoding());
    }
    if (from._has_bit(1)) {
      set_width(from.width());
    }
    if (from._has_bit(2)) {
      set_height(from.height());
    }
    if (from._has_bit(3)) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::Swap(Image* other) {
  if (other != this) {
    std::swap(encoding_, other->encoding_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* Image::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Image::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Image_reflection_;
}

// ===================================================================

const ::google::protobuf::EnumDescriptor* Landmark_ID_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Landmark_ID_descriptor_;
}
bool Landmark_ID_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 80:
    case 81:
    case 82:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Landmark_ID Landmark::L_INNER_CORNER;
const Landmark_ID Landmark::L_OUTER_CORNER;
const Landmark_ID Landmark::T_CORNER;
const Landmark_ID Landmark::CENTER_CIRCLE;
const Landmark_ID Landmark::BLUE_GOAL_T;
const Landmark_ID Landmark::YELLOW_GOAL_T;
const Landmark_ID Landmark::BLUE_GOAL_RIGHT_L_OR_YELLOW_GOAL_LEFT_L;
const Landmark_ID Landmark::BLUE_GOAL_LEFT_L_OR_YELLOW_GOAL_RIGHT_L;
const Landmark_ID Landmark::BLUE_CORNER_TOP_L_OR_YELLOW_CORNER_BOTTOM_L;
const Landmark_ID Landmark::BLUE_CORNER_BOTTOM_L_OR_YELLOW_CORNER_TOP_L;
const Landmark_ID Landmark::CORNER_INNER_L;
const Landmark_ID Landmark::GOAL_BOX_INNER_L;
const Landmark_ID Landmark::BLUE_GOAL_OUTER_L;
const Landmark_ID Landmark::YELLOW_GOAL_OUTER_L;
const Landmark_ID Landmark::CENTER_T;
const Landmark_ID Landmark::BLUE_CORNER_TOP_L;
const Landmark_ID Landmark::BLUE_CORNER_BOTTOM_L;
const Landmark_ID Landmark::BLUE_GOAL_LEFT_T;
const Landmark_ID Landmark::BLUE_GOAL_RIGHT_T;
const Landmark_ID Landmark::BLUE_GOAL_LEFT_L;
const Landmark_ID Landmark::BLUE_GOAL_RIGHT_L;
const Landmark_ID Landmark::CENTER_BOTTOM_T;
const Landmark_ID Landmark::CENTER_TOP_T;
const Landmark_ID Landmark::YELLOW_CORNER_BOTTOM_L;
const Landmark_ID Landmark::YELLOW_CORNER_TOP_L;
const Landmark_ID Landmark::YELLOW_GOAL_LEFT_T;
const Landmark_ID Landmark::YELLOW_GOAL_RIGHT_T;
const Landmark_ID Landmark::YELLOW_GOAL_LEFT_L;
const Landmark_ID Landmark::YELLOW_GOAL_RIGHT_L;
const Landmark_ID Landmark::CORNER_NO_IDEA_ID;
const Landmark_ID Landmark::TOP_CC;
const Landmark_ID Landmark::BOTTOM_CC;
const Landmark_ID Landmark::BLUE_GOAL_LEFT_POST;
const Landmark_ID Landmark::BLUE_GOAL_RIGHT_POST;
const Landmark_ID Landmark::YELLOW_GOAL_LEFT_POST;
const Landmark_ID Landmark::YELLOW_GOAL_RIGHT_POST;
const Landmark_ID Landmark::BLUE_GOAL_POST;
const Landmark_ID Landmark::YELLOW_GOAL_POST;
const Landmark_ID Landmark::UNKNOWN_FIELD_OBJECT;
const Landmark_ID Landmark::UNKNOWN_LINE;
const Landmark_ID Landmark::SIDE_OR_ENDLINE;
const Landmark_ID Landmark::SIDELINE_LINE;
const Landmark_ID Landmark::ENDLINE_LINE;
const Landmark_ID Landmark::GOALBOX_LINE;
const Landmark_ID Landmark::GOALBOX_SIDE_LINE;
const Landmark_ID Landmark::GOALBOX_TOP_LINE;
const Landmark_ID Landmark::BLUE_GOAL_ENDLINE;
const Landmark_ID Landmark::YELLOW_GOAL_ENDLINE;
const Landmark_ID Landmark::BLUE_YELLOW_SIDELINE;
const Landmark_ID Landmark::YELLOW_BLUE_SIDELINE;
const Landmark_ID Landmark::CENTER_FIELD_LINE;
const Landmark_ID Landmark::BLUE_GOALBOX_TOP_LINE;
const Landmark_ID Landmark::BLUE_GOALBOX_LEFT_LINE;
const Landmark_ID Landmark::BLUE_GOALBOX_RIGHT_LINE;
const Landmark_ID Landmark::YELLOW_GOALBOX_TOP_LINE;
const Landmark_ID Landmark::YELLOW_GOALBOX_LEFT_LINE;
const Landmark_ID Landmark::YELLOW_GOALBOX_RIGHT_LINE;
const Landmark_ID Landmark::BLUE_GOAL_CROSS;
const Landmark_ID Landmark::YELLOW_GOAL_CROSS;
const Landmark_ID Landmark::ABSTRACT_CROSS;
const Landmark_ID Landmark::ID_MIN;
const Landmark_ID Landmark::ID_MAX;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Landmark_IDCertainty_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Landmark_IDCertainty_descriptor_;
}
bool Landmark_IDCertainty_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Landmark_IDCertainty Landmark::NOT_SURE;
const Landmark_IDCertainty Landmark::MILDY_SURE;
const Landmark_IDCertainty Landmark::_SURE;
const Landmark_IDCertainty Landmark::IDCertainty_MIN;
const Landmark_IDCertainty Landmark::IDCertainty_MAX;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Landmark_DistanceCertainty_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Landmark_DistanceCertainty_descriptor_;
}
bool Landmark_DistanceCertainty_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Landmark_DistanceCertainty Landmark::BOTH_UNSURE;
const Landmark_DistanceCertainty Landmark::WIDTH_UNSURE;
const Landmark_DistanceCertainty Landmark::HEIGHT_UNSURE;
const Landmark_DistanceCertainty Landmark::BOTH_SURE;
const Landmark_DistanceCertainty Landmark::DistanceCertainty_MIN;
const Landmark_DistanceCertainty Landmark::DistanceCertainty_MAX;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Landmark::kIdFieldNumber;
const int Landmark::kFieldXFieldNumber;
const int Landmark::kFieldYFieldNumber;
const int Landmark::kIdCertaintyFieldNumber;
const int Landmark::kDistanceCertaintyFieldNumber;
#endif  // !_MSC_VER

Landmark::Landmark()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Landmark::InitAsDefaultInstance() {}

Landmark::Landmark(const Landmark& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Landmark::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  field_x_ = 0;
  field_y_ = 0;
  id_certainty_ = 0;
  distance_certainty_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Landmark::~Landmark() {
  SharedDtor();
}

void Landmark::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Landmark::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Landmark_descriptor_;
}

const Landmark& Landmark::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Landmark* Landmark::default_instance_ = NULL;

Landmark* Landmark::New() const {
  return new Landmark;
}

void Landmark::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    field_x_ = 0;
    field_y_ = 0;
    id_certainty_ = 0;
    distance_certainty_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Landmark::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Landmark.ID id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (::man::vision::Landmark_ID_IsValid(value)) {
          set_id(static_cast< ::man::vision::Landmark_ID >(value));
        } else {
          mutable_unknown_fields()->AddVarint(1, value);
        }
        if (input->ExpectTag(21)) goto parse_field_x;
        break;
      }
      
      // required float field_x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_field_x:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &field_x_));
        _set_bit(1);
        if (input->ExpectTag(29)) goto parse_field_y;
        break;
      }
      
      // required float field_y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_field_y:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &field_y_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_id_certainty;
        break;
      }
      
      // optional .man.vision.Landmark.IDCertainty id_certainty = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_id_certainty:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (::man::vision::Landmark_IDCertainty_IsValid(value)) {
          set_id_certainty(static_cast< ::man::vision::Landmark_IDCertainty >(value));
        } else {
          mutable_unknown_fields()->AddVarint(4, value);
        }
        if (input->ExpectTag(40)) goto parse_distance_certainty;
        break;
      }
      
      // optional .man.vision.Landmark.DistanceCertainty distance_certainty = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_distance_certainty:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (::man::vision::Landmark_DistanceCertainty_IsValid(value)) {
          set_distance_certainty(static_cast< ::man::vision::Landmark_DistanceCertainty >(value));
        } else {
          mutable_unknown_fields()->AddVarint(5, value);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        if ((80u <= tag && tag < 808u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Landmark::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Landmark::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Landmark.ID id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(1, this->id(), output);
  }
  
  // required float field_x = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(2, this->field_x(), output);
  }
  
  // required float field_y = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(3, this->field_y(), output);
  }
  
  // optional .man.vision.Landmark.IDCertainty id_certainty = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(4, this->id_certainty(), output);
  }
  
  // optional .man.vision.Landmark.DistanceCertainty distance_certainty = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(5, this->distance_certainty(), output);
  }
  
  // Extension range [10, 101)
  _extensions_.SerializeWithCachedSizes(
      10, 101, output);
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Landmark::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Landmark.ID id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(1, this->id(), target);
  }
  
  // required float field_x = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(2, this->field_x(), target);
  }
  
  // required float field_y = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(3, this->field_y(), target);
  }
  
  // optional .man.vision.Landmark.IDCertainty id_certainty = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(4, this->id_certainty(), target);
  }
  
  // optional .man.vision.Landmark.DistanceCertainty distance_certainty = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(5, this->distance_certainty(), target);
  }
  
  // Extension range [10, 101)
  target = _extensions_.SerializeWithCachedSizesToArray(
      10, 101, target);
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Landmark::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Landmark.ID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->id());
    }
    
    // required float field_x = 2;
    if (has_field_x()) {
      total_size += 1 + 4;
    }
    
    // required float field_y = 3;
    if (has_field_y()) {
      total_size += 1 + 4;
    }
    
    // optional .man.vision.Landmark.IDCertainty id_certainty = 4;
    if (has_id_certainty()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->id_certainty());
    }
    
    // optional .man.vision.Landmark.DistanceCertainty distance_certainty = 5;
    if (has_distance_certainty()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->distance_certainty());
    }
    
  }
  total_size += _extensions_.ByteSize();
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Landmark::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Landmark* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Landmark*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Landmark::MergeFrom(const Landmark& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_field_x(from.field_x());
    }
    if (from._has_bit(2)) {
      set_field_y(from.field_y());
    }
    if (from._has_bit(3)) {
      set_id_certainty(from.id_certainty());
    }
    if (from._has_bit(4)) {
      set_distance_certainty(from.distance_certainty());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Landmark::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Landmark::CopyFrom(const Landmark& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Landmark::Swap(Landmark* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(field_x_, other->field_x_);
    std::swap(field_y_, other->field_y_);
    std::swap(id_certainty_, other->id_certainty_);
    std::swap(distance_certainty_, other->distance_certainty_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

bool Landmark::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  
  if (!_extensions_.IsInitialized()) return false;  return true;
}

const ::google::protobuf::Descriptor* Landmark::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Landmark::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Landmark_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int DistanceBearing::kDistanceFieldNumber;
const int DistanceBearing::kBearingFieldNumber;
const int DistanceBearing::kDistanceSdFieldNumber;
const int DistanceBearing::kBearingSdFieldNumber;
#endif  // !_MSC_VER

DistanceBearing::DistanceBearing()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DistanceBearing::InitAsDefaultInstance() {}

DistanceBearing::DistanceBearing(const DistanceBearing& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DistanceBearing::SharedCtor() {
  _cached_size_ = 0;
  distance_ = 0;
  bearing_ = 0;
  distance_sd_ = 0;
  bearing_sd_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DistanceBearing::~DistanceBearing() {
  SharedDtor();
}

void DistanceBearing::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* DistanceBearing::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DistanceBearing_descriptor_;
}

const DistanceBearing& DistanceBearing::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

DistanceBearing* DistanceBearing::default_instance_ = NULL;

DistanceBearing* DistanceBearing::New() const {
  return new DistanceBearing;
}

void DistanceBearing::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    distance_ = 0;
    bearing_ = 0;
    distance_sd_ = 0;
    bearing_sd_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DistanceBearing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required float distance = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &distance_));
        _set_bit(0);
        if (input->ExpectTag(21)) goto parse_bearing;
        break;
      }
      
      // required float bearing = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_bearing:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &bearing_));
        _set_bit(1);
        if (input->ExpectTag(29)) goto parse_distance_sd;
        break;
      }
      
      // required float distance_sd = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_distance_sd:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &distance_sd_));
        _set_bit(2);
        if (input->ExpectTag(37)) goto parse_bearing_sd;
        break;
      }
      
      // required float bearing_sd = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_bearing_sd:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &bearing_sd_));
        _set_bit(3);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DistanceBearing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    DistanceBearing::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required float distance = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(1, this->distance(), output);
  }
  
  // required float bearing = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(2, this->bearing(), output);
  }
  
  // required float distance_sd = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(3, this->distance_sd(), output);
  }
  
  // required float bearing_sd = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(4, this->bearing_sd(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DistanceBearing::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float distance = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(1, this->distance(), target);
  }
  
  // required float bearing = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(2, this->bearing(), target);
  }
  
  // required float distance_sd = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(3, this->distance_sd(), target);
  }
  
  // required float bearing_sd = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(4, this->bearing_sd(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DistanceBearing::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float distance = 1;
    if (has_distance()) {
      total_size += 1 + 4;
    }
    
    // required float bearing = 2;
    if (has_bearing()) {
      total_size += 1 + 4;
    }
    
    // required float distance_sd = 3;
    if (has_distance_sd()) {
      total_size += 1 + 4;
    }
    
    // required float bearing_sd = 4;
    if (has_bearing_sd()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void DistanceBearing::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DistanceBearing* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DistanceBearing*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DistanceBearing::MergeFrom(const DistanceBearing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_distance(from.distance());
    }
    if (from._has_bit(1)) {
      set_bearing(from.bearing());
    }
    if (from._has_bit(2)) {
      set_distance_sd(from.distance_sd());
    }
    if (from._has_bit(3)) {
      set_bearing_sd(from.bearing_sd());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DistanceBearing::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DistanceBearing::CopyFrom(const DistanceBearing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DistanceBearing::Swap(DistanceBearing* other) {
  if (other != this) {
    std::swap(distance_, other->distance_);
    std::swap(bearing_, other->bearing_);
    std::swap(distance_sd_, other->distance_sd_);
    std::swap(bearing_sd_, other->bearing_sd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool DistanceBearing::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* DistanceBearing::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* DistanceBearing::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return DistanceBearing_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int Detection::kXFieldNumber;
const int Detection::kYFieldNumber;
const int Detection::kWidthFieldNumber;
const int Detection::kHeightFieldNumber;
const int Detection::kCenterXFieldNumber;
const int Detection::kCenterYFieldNumber;
const int Detection::kAngleXFieldNumber;
const int Detection::kAngleYFieldNumber;
const int Detection::kFocDistFieldNumber;
const int Detection::kElevationFieldNumber;
const int Detection::kDbFieldNumber;
#endif  // !_MSC_VER

Detection::Detection()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Detection::InitAsDefaultInstance() {  db_ = const_cast< ::man::vision::DistanceBearing*>(&::man::vision::DistanceBearing::default_instance());
}

Detection::Detection(const Detection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Detection::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  width_ = 0;
  height_ = 0;
  center_x_ = 0;
  center_y_ = 0;
  angle_x_ = 0;
  angle_y_ = 0;
  foc_dist_ = 0;
  elevation_ = 0;
  db_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Detection::~Detection() {
  SharedDtor();
}

void Detection::SharedDtor() {
  if (this != default_instance_) {
    delete db_;
  }
}

const ::google::protobuf::Descriptor* Detection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Detection_descriptor_;
}

const Detection& Detection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Detection* Detection::default_instance_ = NULL;

Detection* Detection::New() const {
  return new Detection;
}

void Detection::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    width_ = 0;
    height_ = 0;
    center_x_ = 0;
    center_y_ = 0;
    angle_x_ = 0;
    angle_y_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    foc_dist_ = 0;
    elevation_ = 0;
    if (_has_bit(10)) {
      if (db_ != NULL) db_->::man::vision::DistanceBearing::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Detection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &x_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }
      
      // required int32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_y:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &y_));
        _set_bit(1);
        if (input->ExpectTag(29)) goto parse_width;
        break;
      }
      
      // required float width = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_width:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &width_));
        _set_bit(2);
        if (input->ExpectTag(37)) goto parse_height;
        break;
      }
      
      // required float height = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_height:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &height_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_center_x;
        break;
      }
      
      // required int32 center_x = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_center_x:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &center_x_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_center_y;
        break;
      }
      
      // required int32 center_y = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_center_y:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &center_y_));
        _set_bit(5);
        if (input->ExpectTag(61)) goto parse_angle_x;
        break;
      }
      
      // required float angle_x = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_angle_x:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &angle_x_));
        _set_bit(6);
        if (input->ExpectTag(69)) goto parse_angle_y;
        break;
      }
      
      // required float angle_y = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_angle_y:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &angle_y_));
        _set_bit(7);
        if (input->ExpectTag(77)) goto parse_foc_dist;
        break;
      }
      
      // required float foc_dist = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_foc_dist:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &foc_dist_));
        _set_bit(8);
        if (input->ExpectTag(85)) goto parse_elevation;
        break;
      }
      
      // required float elevation = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_elevation:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &elevation_));
        _set_bit(9);
        if (input->ExpectTag(90)) goto parse_db;
        break;
      }
      
      // required .man.vision.DistanceBearing db = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_db:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_db()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        if ((160u <= tag && tag < 1608u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Detection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Detection::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(1, this->x(), output);
  }
  
  // required int32 y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(2, this->y(), output);
  }
  
  // required float width = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(3, this->width(), output);
  }
  
  // required float height = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(4, this->height(), output);
  }
  
  // required int32 center_x = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(5, this->center_x(), output);
  }
  
  // required int32 center_y = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(6, this->center_y(), output);
  }
  
  // required float angle_x = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(7, this->angle_x(), output);
  }
  
  // required float angle_y = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(8, this->angle_y(), output);
  }
  
  // required float foc_dist = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(9, this->foc_dist(), output);
  }
  
  // required float elevation = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(10, this->elevation(), output);
  }
  
  // required .man.vision.DistanceBearing db = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(11, this->db(), output);
  }
  
  // Extension range [20, 201)
  _extensions_.SerializeWithCachedSizes(
      20, 201, output);
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Detection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(1, this->x(), target);
  }
  
  // required int32 y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(2, this->y(), target);
  }
  
  // required float width = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(3, this->width(), target);
  }
  
  // required float height = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(4, this->height(), target);
  }
  
  // required int32 center_x = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(5, this->center_x(), target);
  }
  
  // required int32 center_y = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(6, this->center_y(), target);
  }
  
  // required float angle_x = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(7, this->angle_x(), target);
  }
  
  // required float angle_y = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(8, this->angle_y(), target);
  }
  
  // required float foc_dist = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(9, this->foc_dist(), target);
  }
  
  // required float elevation = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(10, this->elevation(), target);
  }
  
  // required .man.vision.DistanceBearing db = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(11, this->db(), target);
  }
  
  // Extension range [20, 201)
  target = _extensions_.SerializeWithCachedSizesToArray(
      20, 201, target);
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Detection::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->x());
    }
    
    // required int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->y());
    }
    
    // required float width = 3;
    if (has_width()) {
      total_size += 1 + 4;
    }
    
    // required float height = 4;
    if (has_height()) {
      total_size += 1 + 4;
    }
    
    // required int32 center_x = 5;
    if (has_center_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->center_x());
    }
    
    // required int32 center_y = 6;
    if (has_center_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->center_y());
    }
    
    // required float angle_x = 7;
    if (has_angle_x()) {
      total_size += 1 + 4;
    }
    
    // required float angle_y = 8;
    if (has_angle_y()) {
      total_size += 1 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float foc_dist = 9;
    if (has_foc_dist()) {
      total_size += 1 + 4;
    }
    
    // required float elevation = 10;
    if (has_elevation()) {
      total_size += 1 + 4;
    }
    
    // required .man.vision.DistanceBearing db = 11;
    if (has_db()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->db());
    }
    
  }
  total_size += _extensions_.ByteSize();
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Detection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Detection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Detection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Detection::MergeFrom(const Detection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_x(from.x());
    }
    if (from._has_bit(1)) {
      set_y(from.y());
    }
    if (from._has_bit(2)) {
      set_width(from.width());
    }
    if (from._has_bit(3)) {
      set_height(from.height());
    }
    if (from._has_bit(4)) {
      set_center_x(from.center_x());
    }
    if (from._has_bit(5)) {
      set_center_y(from.center_y());
    }
    if (from._has_bit(6)) {
      set_angle_x(from.angle_x());
    }
    if (from._has_bit(7)) {
      set_angle_y(from.angle_y());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_foc_dist(from.foc_dist());
    }
    if (from._has_bit(9)) {
      set_elevation(from.elevation());
    }
    if (from._has_bit(10)) {
      mutable_db()->::man::vision::DistanceBearing::MergeFrom(from.db());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Detection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Detection::CopyFrom(const Detection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Detection::Swap(Detection* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(center_x_, other->center_x_);
    std::swap(center_y_, other->center_y_);
    std::swap(angle_x_, other->angle_x_);
    std::swap(angle_y_, other->angle_y_);
    std::swap(foc_dist_, other->foc_dist_);
    std::swap(elevation_, other->elevation_);
    std::swap(db_, other->db_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

bool Detection::IsInitialized() const {
  if ((_has_bits_[0] & 0x000007ff) != 0x000007ff) return false;
  
  if (has_db()) {
    if (!this->db().IsInitialized()) return false;
  }
  
  if (!_extensions_.IsInitialized()) return false;  return true;
}

const ::google::protobuf::Descriptor* Detection::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Detection::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Detection_reflection_;
}

// ===================================================================

const ::google::protobuf::EnumDescriptor* Line_ScanDirection_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Line_ScanDirection_descriptor_;
}
bool Line_ScanDirection_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Line_ScanDirection Line::HORIZONTAL;
const Line_ScanDirection Line::VERTICAL;
const Line_ScanDirection Line::ScanDirection_MIN;
const Line_ScanDirection Line::ScanDirection_MAX;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Line_LinePoint::kXFieldNumber;
const int Line_LinePoint::kYFieldNumber;
const int Line_LinePoint::kLineWidthFieldNumber;
const int Line_LinePoint::kDistanceFieldNumber;
const int Line_LinePoint::kFoundWithScanFieldNumber;
#endif  // !_MSC_VER

Line_LinePoint::Line_LinePoint()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Line_LinePoint::InitAsDefaultInstance() {}

Line_LinePoint::Line_LinePoint(const Line_LinePoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Line_LinePoint::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  line_width_ = 0;
  distance_ = 0;
  found_with_scan_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Line_LinePoint::~Line_LinePoint() {
  SharedDtor();
}

void Line_LinePoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Line_LinePoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Line_LinePoint_descriptor_;
}

const Line_LinePoint& Line_LinePoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Line_LinePoint* Line_LinePoint::default_instance_ = NULL;

Line_LinePoint* Line_LinePoint::New() const {
  return new Line_LinePoint;
}

void Line_LinePoint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    line_width_ = 0;
    distance_ = 0;
    found_with_scan_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Line_LinePoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &x_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }
      
      // required int32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_y:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &y_));
        _set_bit(1);
        if (input->ExpectTag(29)) goto parse_line_width;
        break;
      }
      
      // required float line_width = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_line_width:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &line_width_));
        _set_bit(2);
        if (input->ExpectTag(37)) goto parse_distance;
        break;
      }
      
      // required float distance = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_distance:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &distance_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_found_with_scan;
        break;
      }
      
      // required .man.vision.Line.ScanDirection found_with_scan = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_found_with_scan:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (::man::vision::Line_ScanDirection_IsValid(value)) {
          set_found_with_scan(static_cast< ::man::vision::Line_ScanDirection >(value));
        } else {
          mutable_unknown_fields()->AddVarint(5, value);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Line_LinePoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Line_LinePoint::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(1, this->x(), output);
  }
  
  // required int32 y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(2, this->y(), output);
  }
  
  // required float line_width = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(3, this->line_width(), output);
  }
  
  // required float distance = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(4, this->distance(), output);
  }
  
  // required .man.vision.Line.ScanDirection found_with_scan = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(5, this->found_with_scan(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Line_LinePoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(1, this->x(), target);
  }
  
  // required int32 y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(2, this->y(), target);
  }
  
  // required float line_width = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(3, this->line_width(), target);
  }
  
  // required float distance = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(4, this->distance(), target);
  }
  
  // required .man.vision.Line.ScanDirection found_with_scan = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(5, this->found_with_scan(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Line_LinePoint::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->x());
    }
    
    // required int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->y());
    }
    
    // required float line_width = 3;
    if (has_line_width()) {
      total_size += 1 + 4;
    }
    
    // required float distance = 4;
    if (has_distance()) {
      total_size += 1 + 4;
    }
    
    // required .man.vision.Line.ScanDirection found_with_scan = 5;
    if (has_found_with_scan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->found_with_scan());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Line_LinePoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Line_LinePoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Line_LinePoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Line_LinePoint::MergeFrom(const Line_LinePoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_x(from.x());
    }
    if (from._has_bit(1)) {
      set_y(from.y());
    }
    if (from._has_bit(2)) {
      set_line_width(from.line_width());
    }
    if (from._has_bit(3)) {
      set_distance(from.distance());
    }
    if (from._has_bit(4)) {
      set_found_with_scan(from.found_with_scan());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Line_LinePoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line_LinePoint::CopyFrom(const Line_LinePoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line_LinePoint::Swap(Line_LinePoint* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(line_width_, other->line_width_);
    std::swap(distance_, other->distance_);
    std::swap(found_with_scan_, other->found_with_scan_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Line_LinePoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* Line_LinePoint::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Line_LinePoint::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Line_LinePoint_reflection_;
}

// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Line::kSelfFieldNumber;
const int Line::kPossiblesFieldNumber;
const int Line::kPointsFieldNumber;
const int Line::kAngleFieldNumber;
const int Line::kAFieldNumber;
const int Line::kBFieldNumber;
const int Line::kLengthFieldNumber;
const int Line::kAvgVerticalWidthFieldNumber;
const int Line::kAvgHorizontalWidthFieldNumber;
const int Line::kThinnestHorPointFieldNumber;
const int Line::kThickestHorPointFieldNumber;
const int Line::kThinnestVertPointFieldNumber;
const int Line::kThickestVertPointFieldNumber;
const int Line::kDbFieldNumber;
const int Line::kCcLineFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Line::kFieldX2FieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::man::vision::Landmark,
    ::google::protobuf::internal::PrimitiveTypeTraits< float >, 2, false >
  Line::field_x2(kFieldX2FieldNumber, 0);
#ifndef _MSC_VER
const int Line::kFieldY2FieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::man::vision::Landmark,
    ::google::protobuf::internal::PrimitiveTypeTraits< float >, 2, false >
  Line::field_y2(kFieldY2FieldNumber, 0);
Line::Line()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Line::InitAsDefaultInstance() {  self_ = const_cast< ::man::vision::Landmark*>(&::man::vision::Landmark::default_instance());
  thinnest_hor_point_ = const_cast< ::man::vision::Line_LinePoint*>(&::man::vision::Line_LinePoint::default_instance());
  thickest_hor_point_ = const_cast< ::man::vision::Line_LinePoint*>(&::man::vision::Line_LinePoint::default_instance());
  thinnest_vert_point_ = const_cast< ::man::vision::Line_LinePoint*>(&::man::vision::Line_LinePoint::default_instance());
  thickest_vert_point_ = const_cast< ::man::vision::Line_LinePoint*>(&::man::vision::Line_LinePoint::default_instance());
  db_ = const_cast< ::man::vision::DistanceBearing*>(&::man::vision::DistanceBearing::default_instance());
}

Line::Line(const Line& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Line::SharedCtor() {
  _cached_size_ = 0;
  self_ = NULL;
  angle_ = 0;
  a_ = 0;
  b_ = 0;
  length_ = 0;
  avg_vertical_width_ = 0;
  avg_horizontal_width_ = 0;
  thinnest_hor_point_ = NULL;
  thickest_hor_point_ = NULL;
  thinnest_vert_point_ = NULL;
  thickest_vert_point_ = NULL;
  db_ = NULL;
  cc_line_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Line::~Line() {
  SharedDtor();
}

void Line::SharedDtor() {
  if (this != default_instance_) {
    delete self_;
    delete thinnest_hor_point_;
    delete thickest_hor_point_;
    delete thinnest_vert_point_;
    delete thickest_vert_point_;
    delete db_;
  }
}

const ::google::protobuf::Descriptor* Line::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Line_descriptor_;
}

const Line& Line::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Line* Line::default_instance_ = NULL;

Line* Line::New() const {
  return new Line;
}

void Line::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (self_ != NULL) self_->::man::vision::Landmark::Clear();
    }
    angle_ = 0;
    a_ = 0;
    b_ = 0;
    length_ = 0;
    avg_vertical_width_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    avg_horizontal_width_ = 0;
    if (_has_bit(9)) {
      if (thinnest_hor_point_ != NULL) thinnest_hor_point_->::man::vision::Line_LinePoint::Clear();
    }
    if (_has_bit(10)) {
      if (thickest_hor_point_ != NULL) thickest_hor_point_->::man::vision::Line_LinePoint::Clear();
    }
    if (_has_bit(11)) {
      if (thinnest_vert_point_ != NULL) thinnest_vert_point_->::man::vision::Line_LinePoint::Clear();
    }
    if (_has_bit(12)) {
      if (thickest_vert_point_ != NULL) thickest_vert_point_->::man::vision::Line_LinePoint::Clear();
    }
    if (_has_bit(13)) {
      if (db_ != NULL) db_->::man::vision::DistanceBearing::Clear();
    }
    cc_line_ = false;
  }
  possibles_.Clear();
  points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Line::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Landmark self = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_self()));
        if (input->ExpectTag(18)) goto parse_possibles;
        break;
      }
      
      // repeated .man.vision.Landmark possibles = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_possibles:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_possibles()));
        if (input->ExpectTag(18)) goto parse_possibles;
        if (input->ExpectTag(26)) goto parse_points;
        break;
      }
      
      // repeated .man.vision.Line.LinePoint points = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_points:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_points()));
        if (input->ExpectTag(26)) goto parse_points;
        if (input->ExpectTag(37)) goto parse_angle;
        break;
      }
      
      // optional float angle = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_angle:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &angle_));
        _set_bit(3);
        if (input->ExpectTag(45)) goto parse_a;
        break;
      }
      
      // optional float a = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_a:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &a_));
        _set_bit(4);
        if (input->ExpectTag(53)) goto parse_b;
        break;
      }
      
      // optional float b = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_b:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &b_));
        _set_bit(5);
        if (input->ExpectTag(61)) goto parse_length;
        break;
      }
      
      // optional float length = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_length:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &length_));
        _set_bit(6);
        if (input->ExpectTag(69)) goto parse_avg_vertical_width;
        break;
      }
      
      // optional float avg_vertical_width = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_avg_vertical_width:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &avg_vertical_width_));
        _set_bit(7);
        if (input->ExpectTag(77)) goto parse_avg_horizontal_width;
        break;
      }
      
      // optional float avg_horizontal_width = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_avg_horizontal_width:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &avg_horizontal_width_));
        _set_bit(8);
        if (input->ExpectTag(82)) goto parse_thinnest_hor_point;
        break;
      }
      
      // optional .man.vision.Line.LinePoint thinnest_hor_point = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_thinnest_hor_point:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_thinnest_hor_point()));
        if (input->ExpectTag(90)) goto parse_thickest_hor_point;
        break;
      }
      
      // optional .man.vision.Line.LinePoint thickest_hor_point = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_thickest_hor_point:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_thickest_hor_point()));
        if (input->ExpectTag(98)) goto parse_thinnest_vert_point;
        break;
      }
      
      // optional .man.vision.Line.LinePoint thinnest_vert_point = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_thinnest_vert_point:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_thinnest_vert_point()));
        if (input->ExpectTag(106)) goto parse_thickest_vert_point;
        break;
      }
      
      // optional .man.vision.Line.LinePoint thickest_vert_point = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_thickest_vert_point:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_thickest_vert_point()));
        if (input->ExpectTag(114)) goto parse_db;
        break;
      }
      
      // required .man.vision.DistanceBearing db = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_db:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_db()));
        if (input->ExpectTag(120)) goto parse_cc_line;
        break;
      }
      
      // required bool cc_line = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_cc_line:
        DO_(::google::protobuf::internal::WireFormat::ReadBool(
              input, &cc_line_));
        _set_bit(14);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Line::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Line::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->self(), output);
  }
  
  // repeated .man.vision.Landmark possibles = 2;
  for (int i = 0; i < this->possibles_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->possibles(i), output);
  }
  
  // repeated .man.vision.Line.LinePoint points = 3;
  for (int i = 0; i < this->points_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->points(i), output);
  }
  
  // optional float angle = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(4, this->angle(), output);
  }
  
  // optional float a = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(5, this->a(), output);
  }
  
  // optional float b = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(6, this->b(), output);
  }
  
  // optional float length = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(7, this->length(), output);
  }
  
  // optional float avg_vertical_width = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(8, this->avg_vertical_width(), output);
  }
  
  // optional float avg_horizontal_width = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(9, this->avg_horizontal_width(), output);
  }
  
  // optional .man.vision.Line.LinePoint thinnest_hor_point = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(10, this->thinnest_hor_point(), output);
  }
  
  // optional .man.vision.Line.LinePoint thickest_hor_point = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(11, this->thickest_hor_point(), output);
  }
  
  // optional .man.vision.Line.LinePoint thinnest_vert_point = 12;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(12, this->thinnest_vert_point(), output);
  }
  
  // optional .man.vision.Line.LinePoint thickest_vert_point = 13;
  if (_has_bit(12)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(13, this->thickest_vert_point(), output);
  }
  
  // required .man.vision.DistanceBearing db = 14;
  if (_has_bit(13)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(14, this->db(), output);
  }
  
  // required bool cc_line = 15;
  if (_has_bit(14)) {
    ::google::protobuf::internal::WireFormat::WriteBool(15, this->cc_line(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Line::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->self(), target);
  }
  
  // repeated .man.vision.Landmark possibles = 2;
  for (int i = 0; i < this->possibles_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->possibles(i), target);
  }
  
  // repeated .man.vision.Line.LinePoint points = 3;
  for (int i = 0; i < this->points_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(3, this->points(i), target);
  }
  
  // optional float angle = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(4, this->angle(), target);
  }
  
  // optional float a = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(5, this->a(), target);
  }
  
  // optional float b = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(6, this->b(), target);
  }
  
  // optional float length = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(7, this->length(), target);
  }
  
  // optional float avg_vertical_width = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(8, this->avg_vertical_width(), target);
  }
  
  // optional float avg_horizontal_width = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(9, this->avg_horizontal_width(), target);
  }
  
  // optional .man.vision.Line.LinePoint thinnest_hor_point = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(10, this->thinnest_hor_point(), target);
  }
  
  // optional .man.vision.Line.LinePoint thickest_hor_point = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(11, this->thickest_hor_point(), target);
  }
  
  // optional .man.vision.Line.LinePoint thinnest_vert_point = 12;
  if (_has_bit(11)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(12, this->thinnest_vert_point(), target);
  }
  
  // optional .man.vision.Line.LinePoint thickest_vert_point = 13;
  if (_has_bit(12)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(13, this->thickest_vert_point(), target);
  }
  
  // required .man.vision.DistanceBearing db = 14;
  if (_has_bit(13)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(14, this->db(), target);
  }
  
  // required bool cc_line = 15;
  if (_has_bit(14)) {
    target = ::google::protobuf::internal::WireFormat::WriteBoolToArray(15, this->cc_line(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Line::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Landmark self = 1;
    if (has_self()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->self());
    }
    
    // optional float angle = 4;
    if (has_angle()) {
      total_size += 1 + 4;
    }
    
    // optional float a = 5;
    if (has_a()) {
      total_size += 1 + 4;
    }
    
    // optional float b = 6;
    if (has_b()) {
      total_size += 1 + 4;
    }
    
    // optional float length = 7;
    if (has_length()) {
      total_size += 1 + 4;
    }
    
    // optional float avg_vertical_width = 8;
    if (has_avg_vertical_width()) {
      total_size += 1 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float avg_horizontal_width = 9;
    if (has_avg_horizontal_width()) {
      total_size += 1 + 4;
    }
    
    // optional .man.vision.Line.LinePoint thinnest_hor_point = 10;
    if (has_thinnest_hor_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->thinnest_hor_point());
    }
    
    // optional .man.vision.Line.LinePoint thickest_hor_point = 11;
    if (has_thickest_hor_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->thickest_hor_point());
    }
    
    // optional .man.vision.Line.LinePoint thinnest_vert_point = 12;
    if (has_thinnest_vert_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->thinnest_vert_point());
    }
    
    // optional .man.vision.Line.LinePoint thickest_vert_point = 13;
    if (has_thickest_vert_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->thickest_vert_point());
    }
    
    // required .man.vision.DistanceBearing db = 14;
    if (has_db()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->db());
    }
    
    // required bool cc_line = 15;
    if (has_cc_line()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .man.vision.Landmark possibles = 2;
  total_size += 1 * this->possibles_size();
  for (int i = 0; i < this->possibles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->possibles(i));
  }
  
  // repeated .man.vision.Line.LinePoint points = 3;
  total_size += 1 * this->points_size();
  for (int i = 0; i < this->points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->points(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Line::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Line* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Line*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Line::MergeFrom(const Line& from) {
  GOOGLE_CHECK_NE(&from, this);
  possibles_.MergeFrom(from.possibles_);
  points_.MergeFrom(from.points_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_self()->::man::vision::Landmark::MergeFrom(from.self());
    }
    if (from._has_bit(3)) {
      set_angle(from.angle());
    }
    if (from._has_bit(4)) {
      set_a(from.a());
    }
    if (from._has_bit(5)) {
      set_b(from.b());
    }
    if (from._has_bit(6)) {
      set_length(from.length());
    }
    if (from._has_bit(7)) {
      set_avg_vertical_width(from.avg_vertical_width());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_avg_horizontal_width(from.avg_horizontal_width());
    }
    if (from._has_bit(9)) {
      mutable_thinnest_hor_point()->::man::vision::Line_LinePoint::MergeFrom(from.thinnest_hor_point());
    }
    if (from._has_bit(10)) {
      mutable_thickest_hor_point()->::man::vision::Line_LinePoint::MergeFrom(from.thickest_hor_point());
    }
    if (from._has_bit(11)) {
      mutable_thinnest_vert_point()->::man::vision::Line_LinePoint::MergeFrom(from.thinnest_vert_point());
    }
    if (from._has_bit(12)) {
      mutable_thickest_vert_point()->::man::vision::Line_LinePoint::MergeFrom(from.thickest_vert_point());
    }
    if (from._has_bit(13)) {
      mutable_db()->::man::vision::DistanceBearing::MergeFrom(from.db());
    }
    if (from._has_bit(14)) {
      set_cc_line(from.cc_line());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Line::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line::CopyFrom(const Line& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line::Swap(Line* other) {
  if (other != this) {
    std::swap(self_, other->self_);
    possibles_.Swap(&other->possibles_);
    points_.Swap(&other->points_);
    std::swap(angle_, other->angle_);
    std::swap(a_, other->a_);
    std::swap(b_, other->b_);
    std::swap(length_, other->length_);
    std::swap(avg_vertical_width_, other->avg_vertical_width_);
    std::swap(avg_horizontal_width_, other->avg_horizontal_width_);
    std::swap(thinnest_hor_point_, other->thinnest_hor_point_);
    std::swap(thickest_hor_point_, other->thickest_hor_point_);
    std::swap(thinnest_vert_point_, other->thinnest_vert_point_);
    std::swap(thickest_vert_point_, other->thickest_vert_point_);
    std::swap(db_, other->db_);
    std::swap(cc_line_, other->cc_line_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Line::IsInitialized() const {
  if ((_has_bits_[0] & 0x00006001) != 0x00006001) return false;
  
  if (has_self()) {
    if (!this->self().IsInitialized()) return false;
  }
  for (int i = 0; i < possibles_size(); i++) {
    if (!this->possibles(i).IsInitialized()) return false;
  }
  for (int i = 0; i < points_size(); i++) {
    if (!this->points(i).IsInitialized()) return false;
  }
  if (has_thinnest_hor_point()) {
    if (!this->thinnest_hor_point().IsInitialized()) return false;
  }
  if (has_thickest_hor_point()) {
    if (!this->thickest_hor_point().IsInitialized()) return false;
  }
  if (has_thinnest_vert_point()) {
    if (!this->thinnest_vert_point().IsInitialized()) return false;
  }
  if (has_thickest_vert_point()) {
    if (!this->thickest_vert_point().IsInitialized()) return false;
  }
  if (has_db()) {
    if (!this->db().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Line::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Line::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Line_reflection_;
}

// ===================================================================

const ::google::protobuf::EnumDescriptor* Corner_Shape_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Corner_Shape_descriptor_;
}
bool Corner_Shape_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Corner_Shape Corner::INNER_L;
const Corner_Shape Corner::OUTER_L;
const Corner_Shape Corner::T;
const Corner_Shape Corner::CIRCLE;
const Corner_Shape Corner::UNKNOWN;
const Corner_Shape Corner::Shape_MIN;
const Corner_Shape Corner::Shape_MAX;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Corner::kSelfFieldNumber;
const int Corner::kDetectFieldNumber;
const int Corner::kPossiblesFieldNumber;
const int Corner::kLinesFieldNumber;
const int Corner::kDistsFieldNumber;
const int Corner::kTLinesFieldNumber;
const int Corner::kAngleBetweenLinesFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Corner::kCornerTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::man::vision::Landmark,
    ::google::protobuf::internal::EnumTypeTraits< ::man::vision::Corner_Shape, ::man::vision::Corner_Shape_IsValid>, 14, false >
  Corner::corner_type(kCornerTypeFieldNumber, static_cast< ::man::vision::Corner_Shape >(0));
#ifndef _MSC_VER
const int Corner::kCornerLinesFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::man::vision::Landmark,
    ::google::protobuf::internal::RepeatedMessageTypeTraits< ::man::vision::Landmark >, 11, false >
  Corner::corner_lines(kCornerLinesFieldNumber, ::man::vision::Landmark::default_instance());
Corner::Corner()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Corner::InitAsDefaultInstance() {  self_ = const_cast< ::man::vision::Landmark*>(&::man::vision::Landmark::default_instance());
  detect_ = const_cast< ::man::vision::Detection*>(&::man::vision::Detection::default_instance());
}

Corner::Corner(const Corner& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Corner::SharedCtor() {
  _cached_size_ = 0;
  self_ = NULL;
  detect_ = NULL;
  angle_between_lines_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Corner::~Corner() {
  SharedDtor();
}

void Corner::SharedDtor() {
  if (this != default_instance_) {
    delete self_;
    delete detect_;
  }
}

const ::google::protobuf::Descriptor* Corner::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Corner_descriptor_;
}

const Corner& Corner::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Corner* Corner::default_instance_ = NULL;

Corner* Corner::New() const {
  return new Corner;
}

void Corner::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (self_ != NULL) self_->::man::vision::Landmark::Clear();
    }
    if (_has_bit(1)) {
      if (detect_ != NULL) detect_->::man::vision::Detection::Clear();
    }
    angle_between_lines_ = 0;
  }
  possibles_.Clear();
  lines_.Clear();
  dists_.Clear();
  t_lines_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Corner::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Landmark self = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_self()));
        if (input->ExpectTag(18)) goto parse_detect;
        break;
      }
      
      // required .man.vision.Detection detect = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_detect:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_detect()));
        if (input->ExpectTag(26)) goto parse_possibles;
        break;
      }
      
      // repeated .man.vision.Landmark possibles = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_possibles:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_possibles()));
        if (input->ExpectTag(26)) goto parse_possibles;
        if (input->ExpectTag(34)) goto parse_lines;
        break;
      }
      
      // repeated .man.vision.Line lines = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_lines:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_lines()));
        if (input->ExpectTag(34)) goto parse_lines;
        if (input->ExpectTag(45)) goto parse_dists;
        break;
      }
      
      // repeated float dists = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_dists:
        float value;
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(input, &value));
        add_dists(value);
        if (input->ExpectTag(45)) goto parse_dists;
        if (input->ExpectTag(50)) goto parse_t_lines;
        break;
      }
      
      // repeated .man.vision.Line t_lines = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_t_lines:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_t_lines()));
        if (input->ExpectTag(50)) goto parse_t_lines;
        if (input->ExpectTag(61)) goto parse_angle_between_lines;
        break;
      }
      
      // required float angle_between_lines = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_angle_between_lines:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &angle_between_lines_));
        _set_bit(6);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Corner::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Corner::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->self(), output);
  }
  
  // required .man.vision.Detection detect = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->detect(), output);
  }
  
  // repeated .man.vision.Landmark possibles = 3;
  for (int i = 0; i < this->possibles_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->possibles(i), output);
  }
  
  // repeated .man.vision.Line lines = 4;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(4, this->lines(i), output);
  }
  
  // repeated float dists = 5;
  for (int i = 0; i < this->dists_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteFloat(5, this->dists(i), output);
  }
  
  // repeated .man.vision.Line t_lines = 6;
  for (int i = 0; i < this->t_lines_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(6, this->t_lines(i), output);
  }
  
  // required float angle_between_lines = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(7, this->angle_between_lines(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Corner::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->self(), target);
  }
  
  // required .man.vision.Detection detect = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->detect(), target);
  }
  
  // repeated .man.vision.Landmark possibles = 3;
  for (int i = 0; i < this->possibles_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(3, this->possibles(i), target);
  }
  
  // repeated .man.vision.Line lines = 4;
  for (int i = 0; i < this->lines_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(4, this->lines(i), target);
  }
  
  // repeated float dists = 5;
  for (int i = 0; i < this->dists_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(5, this->dists(i), target);
  }
  
  // repeated .man.vision.Line t_lines = 6;
  for (int i = 0; i < this->t_lines_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(6, this->t_lines(i), target);
  }
  
  // required float angle_between_lines = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(7, this->angle_between_lines(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Corner::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Landmark self = 1;
    if (has_self()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->self());
    }
    
    // required .man.vision.Detection detect = 2;
    if (has_detect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->detect());
    }
    
    // required float angle_between_lines = 7;
    if (has_angle_between_lines()) {
      total_size += 1 + 4;
    }
    
  }
  // repeated .man.vision.Landmark possibles = 3;
  total_size += 1 * this->possibles_size();
  for (int i = 0; i < this->possibles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->possibles(i));
  }
  
  // repeated .man.vision.Line lines = 4;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->lines(i));
  }
  
  // repeated float dists = 5;
  {
    int data_size = 0;
    data_size = 4 * this->dists_size();
    total_size += 1 * this->dists_size() + data_size;
  }
  
  // repeated .man.vision.Line t_lines = 6;
  total_size += 1 * this->t_lines_size();
  for (int i = 0; i < this->t_lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->t_lines(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Corner::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Corner* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Corner*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Corner::MergeFrom(const Corner& from) {
  GOOGLE_CHECK_NE(&from, this);
  possibles_.MergeFrom(from.possibles_);
  lines_.MergeFrom(from.lines_);
  dists_.MergeFrom(from.dists_);
  t_lines_.MergeFrom(from.t_lines_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_self()->::man::vision::Landmark::MergeFrom(from.self());
    }
    if (from._has_bit(1)) {
      mutable_detect()->::man::vision::Detection::MergeFrom(from.detect());
    }
    if (from._has_bit(6)) {
      set_angle_between_lines(from.angle_between_lines());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Corner::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Corner::CopyFrom(const Corner& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Corner::Swap(Corner* other) {
  if (other != this) {
    std::swap(self_, other->self_);
    std::swap(detect_, other->detect_);
    possibles_.Swap(&other->possibles_);
    lines_.Swap(&other->lines_);
    dists_.Swap(&other->dists_);
    t_lines_.Swap(&other->t_lines_);
    std::swap(angle_between_lines_, other->angle_between_lines_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Corner::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000043) != 0x00000043) return false;
  
  if (has_self()) {
    if (!this->self().IsInitialized()) return false;
  }
  if (has_detect()) {
    if (!this->detect().IsInitialized()) return false;
  }
  for (int i = 0; i < possibles_size(); i++) {
    if (!this->possibles(i).IsInitialized()) return false;
  }
  for (int i = 0; i < lines_size(); i++) {
    if (!this->lines(i).IsInitialized()) return false;
  }
  for (int i = 0; i < t_lines_size(); i++) {
    if (!this->t_lines(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Corner::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Corner::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Corner_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int Cross::kSelfFieldNumber;
const int Cross::kDetectFieldNumber;
const int Cross::kPossiblesFieldNumber;
const int Cross::kBoundsFieldNumber;
#endif  // !_MSC_VER

Cross::Cross()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Cross::InitAsDefaultInstance() {  self_ = const_cast< ::man::vision::Landmark*>(&::man::vision::Landmark::default_instance());
  detect_ = const_cast< ::man::vision::Detection*>(&::man::vision::Detection::default_instance());
  bounds_ = const_cast< ::man::Rectangle*>(&::man::Rectangle::default_instance());
}

Cross::Cross(const Cross& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Cross::SharedCtor() {
  _cached_size_ = 0;
  self_ = NULL;
  detect_ = NULL;
  bounds_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Cross::~Cross() {
  SharedDtor();
}

void Cross::SharedDtor() {
  if (this != default_instance_) {
    delete self_;
    delete detect_;
    delete bounds_;
  }
}

const ::google::protobuf::Descriptor* Cross::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Cross_descriptor_;
}

const Cross& Cross::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Cross* Cross::default_instance_ = NULL;

Cross* Cross::New() const {
  return new Cross;
}

void Cross::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (self_ != NULL) self_->::man::vision::Landmark::Clear();
    }
    if (_has_bit(1)) {
      if (detect_ != NULL) detect_->::man::vision::Detection::Clear();
    }
    if (_has_bit(3)) {
      if (bounds_ != NULL) bounds_->::man::Rectangle::Clear();
    }
  }
  possibles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Cross::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Landmark self = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_self()));
        if (input->ExpectTag(18)) goto parse_detect;
        break;
      }
      
      // required .man.vision.Detection detect = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_detect:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_detect()));
        if (input->ExpectTag(26)) goto parse_possibles;
        break;
      }
      
      // repeated .man.vision.Landmark possibles = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_possibles:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_possibles()));
        if (input->ExpectTag(26)) goto parse_possibles;
        if (input->ExpectTag(34)) goto parse_bounds;
        break;
      }
      
      // required .man.Rectangle bounds = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_bounds:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_bounds()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Cross::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Cross::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->self(), output);
  }
  
  // required .man.vision.Detection detect = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->detect(), output);
  }
  
  // repeated .man.vision.Landmark possibles = 3;
  for (int i = 0; i < this->possibles_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->possibles(i), output);
  }
  
  // required .man.Rectangle bounds = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(4, this->bounds(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Cross::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->self(), target);
  }
  
  // required .man.vision.Detection detect = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->detect(), target);
  }
  
  // repeated .man.vision.Landmark possibles = 3;
  for (int i = 0; i < this->possibles_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(3, this->possibles(i), target);
  }
  
  // required .man.Rectangle bounds = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(4, this->bounds(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Cross::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Landmark self = 1;
    if (has_self()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->self());
    }
    
    // required .man.vision.Detection detect = 2;
    if (has_detect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->detect());
    }
    
    // required .man.Rectangle bounds = 4;
    if (has_bounds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->bounds());
    }
    
  }
  // repeated .man.vision.Landmark possibles = 3;
  total_size += 1 * this->possibles_size();
  for (int i = 0; i < this->possibles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->possibles(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Cross::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Cross* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Cross*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Cross::MergeFrom(const Cross& from) {
  GOOGLE_CHECK_NE(&from, this);
  possibles_.MergeFrom(from.possibles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_self()->::man::vision::Landmark::MergeFrom(from.self());
    }
    if (from._has_bit(1)) {
      mutable_detect()->::man::vision::Detection::MergeFrom(from.detect());
    }
    if (from._has_bit(3)) {
      mutable_bounds()->::man::Rectangle::MergeFrom(from.bounds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Cross::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cross::CopyFrom(const Cross& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cross::Swap(Cross* other) {
  if (other != this) {
    std::swap(self_, other->self_);
    std::swap(detect_, other->detect_);
    possibles_.Swap(&other->possibles_);
    std::swap(bounds_, other->bounds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Cross::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;
  
  if (has_self()) {
    if (!this->self().IsInitialized()) return false;
  }
  if (has_detect()) {
    if (!this->detect().IsInitialized()) return false;
  }
  for (int i = 0; i < possibles_size(); i++) {
    if (!this->possibles(i).IsInitialized()) return false;
  }
  if (has_bounds()) {
    if (!this->bounds().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Cross::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Cross::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Cross_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int CrossBar::kDetectFieldNumber;
const int CrossBar::kBoundsFieldNumber;
#endif  // !_MSC_VER

CrossBar::CrossBar()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CrossBar::InitAsDefaultInstance() {  detect_ = const_cast< ::man::vision::Detection*>(&::man::vision::Detection::default_instance());
  bounds_ = const_cast< ::man::Rectangle*>(&::man::Rectangle::default_instance());
}

CrossBar::CrossBar(const CrossBar& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CrossBar::SharedCtor() {
  _cached_size_ = 0;
  detect_ = NULL;
  bounds_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CrossBar::~CrossBar() {
  SharedDtor();
}

void CrossBar::SharedDtor() {
  if (this != default_instance_) {
    delete detect_;
    delete bounds_;
  }
}

const ::google::protobuf::Descriptor* CrossBar::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CrossBar_descriptor_;
}

const CrossBar& CrossBar::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

CrossBar* CrossBar::default_instance_ = NULL;

CrossBar* CrossBar::New() const {
  return new CrossBar;
}

void CrossBar::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (detect_ != NULL) detect_->::man::vision::Detection::Clear();
    }
    if (_has_bit(1)) {
      if (bounds_ != NULL) bounds_->::man::Rectangle::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CrossBar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Detection detect = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_detect()));
        if (input->ExpectTag(18)) goto parse_bounds;
        break;
      }
      
      // required .man.Rectangle bounds = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_bounds:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_bounds()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CrossBar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    CrossBar::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Detection detect = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->detect(), output);
  }
  
  // required .man.Rectangle bounds = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->bounds(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CrossBar::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Detection detect = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->detect(), target);
  }
  
  // required .man.Rectangle bounds = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->bounds(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CrossBar::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Detection detect = 1;
    if (has_detect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->detect());
    }
    
    // required .man.Rectangle bounds = 2;
    if (has_bounds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->bounds());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void CrossBar::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CrossBar* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CrossBar*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CrossBar::MergeFrom(const CrossBar& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_detect()->::man::vision::Detection::MergeFrom(from.detect());
    }
    if (from._has_bit(1)) {
      mutable_bounds()->::man::Rectangle::MergeFrom(from.bounds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CrossBar::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CrossBar::CopyFrom(const CrossBar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CrossBar::Swap(CrossBar* other) {
  if (other != this) {
    std::swap(detect_, other->detect_);
    std::swap(bounds_, other->bounds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool CrossBar::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_detect()) {
    if (!this->detect().IsInitialized()) return false;
  }
  if (has_bounds()) {
    if (!this->bounds().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* CrossBar::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* CrossBar::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return CrossBar_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int FieldObject::kSelfFieldNumber;
const int FieldObject::kPossiblesFieldNumber;
const int FieldObject::kBoundsFieldNumber;
#endif  // !_MSC_VER

FieldObject::FieldObject()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FieldObject::InitAsDefaultInstance() {  self_ = const_cast< ::man::vision::Landmark*>(&::man::vision::Landmark::default_instance());
  possibles_ = const_cast< ::man::vision::Landmark*>(&::man::vision::Landmark::default_instance());
  bounds_ = const_cast< ::man::Rectangle*>(&::man::Rectangle::default_instance());
}

FieldObject::FieldObject(const FieldObject& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FieldObject::SharedCtor() {
  _cached_size_ = 0;
  self_ = NULL;
  possibles_ = NULL;
  bounds_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FieldObject::~FieldObject() {
  SharedDtor();
}

void FieldObject::SharedDtor() {
  if (this != default_instance_) {
    delete self_;
    delete possibles_;
    delete bounds_;
  }
}

const ::google::protobuf::Descriptor* FieldObject::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FieldObject_descriptor_;
}

const FieldObject& FieldObject::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

FieldObject* FieldObject::default_instance_ = NULL;

FieldObject* FieldObject::New() const {
  return new FieldObject;
}

void FieldObject::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (self_ != NULL) self_->::man::vision::Landmark::Clear();
    }
    if (_has_bit(1)) {
      if (possibles_ != NULL) possibles_->::man::vision::Landmark::Clear();
    }
    if (_has_bit(2)) {
      if (bounds_ != NULL) bounds_->::man::Rectangle::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FieldObject::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Landmark self = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_self()));
        if (input->ExpectTag(18)) goto parse_possibles;
        break;
      }
      
      // required .man.vision.Landmark possibles = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_possibles:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_possibles()));
        if (input->ExpectTag(26)) goto parse_bounds;
        break;
      }
      
      // required .man.Rectangle bounds = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_bounds:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_bounds()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FieldObject::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    FieldObject::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->self(), output);
  }
  
  // required .man.vision.Landmark possibles = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->possibles(), output);
  }
  
  // required .man.Rectangle bounds = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->bounds(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FieldObject::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Landmark self = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->self(), target);
  }
  
  // required .man.vision.Landmark possibles = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->possibles(), target);
  }
  
  // required .man.Rectangle bounds = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(3, this->bounds(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FieldObject::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Landmark self = 1;
    if (has_self()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->self());
    }
    
    // required .man.vision.Landmark possibles = 2;
    if (has_possibles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->possibles());
    }
    
    // required .man.Rectangle bounds = 3;
    if (has_bounds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->bounds());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void FieldObject::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FieldObject* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FieldObject*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FieldObject::MergeFrom(const FieldObject& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_self()->::man::vision::Landmark::MergeFrom(from.self());
    }
    if (from._has_bit(1)) {
      mutable_possibles()->::man::vision::Landmark::MergeFrom(from.possibles());
    }
    if (from._has_bit(2)) {
      mutable_bounds()->::man::Rectangle::MergeFrom(from.bounds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FieldObject::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldObject::CopyFrom(const FieldObject& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldObject::Swap(FieldObject* other) {
  if (other != this) {
    std::swap(self_, other->self_);
    std::swap(possibles_, other->possibles_);
    std::swap(bounds_, other->bounds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool FieldObject::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_self()) {
    if (!this->self().IsInitialized()) return false;
  }
  if (has_possibles()) {
    if (!this->possibles().IsInitialized()) return false;
  }
  if (has_bounds()) {
    if (!this->bounds().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* FieldObject::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* FieldObject::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return FieldObject_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int Robot::kDetectFieldNumber;
const int Robot::kBoundsFieldNumber;
const int Robot::kBackLeftFieldNumber;
const int Robot::kBackRightFieldNumber;
const int Robot::kBackDirFieldNumber;
#endif  // !_MSC_VER

Robot::Robot()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Robot::InitAsDefaultInstance() {  detect_ = const_cast< ::man::vision::Detection*>(&::man::vision::Detection::default_instance());
  bounds_ = const_cast< ::man::Rectangle*>(&::man::Rectangle::default_instance());
}

Robot::Robot(const Robot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Robot::SharedCtor() {
  _cached_size_ = 0;
  detect_ = NULL;
  bounds_ = NULL;
  back_left_ = 0;
  back_right_ = 0;
  back_dir_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Robot::~Robot() {
  SharedDtor();
}

void Robot::SharedDtor() {
  if (this != default_instance_) {
    delete detect_;
    delete bounds_;
  }
}

const ::google::protobuf::Descriptor* Robot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Robot_descriptor_;
}

const Robot& Robot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Robot* Robot::default_instance_ = NULL;

Robot* Robot::New() const {
  return new Robot;
}

void Robot::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (detect_ != NULL) detect_->::man::vision::Detection::Clear();
    }
    if (_has_bit(1)) {
      if (bounds_ != NULL) bounds_->::man::Rectangle::Clear();
    }
    back_left_ = 0;
    back_right_ = 0;
    back_dir_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Robot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Detection detect = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_detect()));
        if (input->ExpectTag(18)) goto parse_bounds;
        break;
      }
      
      // required .man.Rectangle bounds = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_bounds:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_bounds()));
        if (input->ExpectTag(24)) goto parse_back_left;
        break;
      }
      
      // required int32 back_left = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_back_left:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &back_left_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_back_right;
        break;
      }
      
      // required int32 back_right = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_back_right:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &back_right_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_back_dir;
        break;
      }
      
      // required int32 back_dir = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_back_dir:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &back_dir_));
        _set_bit(4);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Robot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Robot::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Detection detect = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->detect(), output);
  }
  
  // required .man.Rectangle bounds = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->bounds(), output);
  }
  
  // required int32 back_left = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(3, this->back_left(), output);
  }
  
  // required int32 back_right = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(4, this->back_right(), output);
  }
  
  // required int32 back_dir = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(5, this->back_dir(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Robot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Detection detect = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->detect(), target);
  }
  
  // required .man.Rectangle bounds = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->bounds(), target);
  }
  
  // required int32 back_left = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(3, this->back_left(), target);
  }
  
  // required int32 back_right = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(4, this->back_right(), target);
  }
  
  // required int32 back_dir = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(5, this->back_dir(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Robot::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Detection detect = 1;
    if (has_detect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->detect());
    }
    
    // required .man.Rectangle bounds = 2;
    if (has_bounds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->bounds());
    }
    
    // required int32 back_left = 3;
    if (has_back_left()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->back_left());
    }
    
    // required int32 back_right = 4;
    if (has_back_right()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->back_right());
    }
    
    // required int32 back_dir = 5;
    if (has_back_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->back_dir());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Robot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Robot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Robot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Robot::MergeFrom(const Robot& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_detect()->::man::vision::Detection::MergeFrom(from.detect());
    }
    if (from._has_bit(1)) {
      mutable_bounds()->::man::Rectangle::MergeFrom(from.bounds());
    }
    if (from._has_bit(2)) {
      set_back_left(from.back_left());
    }
    if (from._has_bit(3)) {
      set_back_right(from.back_right());
    }
    if (from._has_bit(4)) {
      set_back_dir(from.back_dir());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Robot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::CopyFrom(const Robot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::Swap(Robot* other) {
  if (other != this) {
    std::swap(detect_, other->detect_);
    std::swap(bounds_, other->bounds_);
    std::swap(back_left_, other->back_left_);
    std::swap(back_right_, other->back_right_);
    std::swap(back_dir_, other->back_dir_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Robot::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_detect()) {
    if (!this->detect().IsInitialized()) return false;
  }
  if (has_bounds()) {
    if (!this->bounds().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Robot::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Robot::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Robot_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int Ball::kDetectFieldNumber;
const int Ball::kRadiusFieldNumber;
const int Ball::kConfidenceFieldNumber;
#endif  // !_MSC_VER

Ball::Ball()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Ball::InitAsDefaultInstance() {  detect_ = const_cast< ::man::vision::Detection*>(&::man::vision::Detection::default_instance());
}

Ball::Ball(const Ball& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Ball::SharedCtor() {
  _cached_size_ = 0;
  detect_ = NULL;
  radius_ = 0;
  confidence_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ball::~Ball() {
  SharedDtor();
}

void Ball::SharedDtor() {
  if (this != default_instance_) {
    delete detect_;
  }
}

const ::google::protobuf::Descriptor* Ball::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ball_descriptor_;
}

const Ball& Ball::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Ball* Ball::default_instance_ = NULL;

Ball* Ball::New() const {
  return new Ball;
}

void Ball::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (detect_ != NULL) detect_->::man::vision::Detection::Clear();
    }
    radius_ = 0;
    confidence_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ball::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .man.vision.Detection detect = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_detect()));
        if (input->ExpectTag(21)) goto parse_radius;
        break;
      }
      
      // required float radius = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED32) {
          goto handle_uninterpreted;
        }
       parse_radius:
        DO_(::google::protobuf::internal::WireFormat::ReadFloat(
              input, &radius_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_confidence;
        break;
      }
      
      // required int32 confidence = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_confidence:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &confidence_));
        _set_bit(2);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ball::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Ball::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .man.vision.Detection detect = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->detect(), output);
  }
  
  // required float radius = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteFloat(2, this->radius(), output);
  }
  
  // required int32 confidence = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(3, this->confidence(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ball::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .man.vision.Detection detect = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->detect(), target);
  }
  
  // required float radius = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteFloatToArray(2, this->radius(), target);
  }
  
  // required int32 confidence = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(3, this->confidence(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ball::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .man.vision.Detection detect = 1;
    if (has_detect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->detect());
    }
    
    // required float radius = 2;
    if (has_radius()) {
      total_size += 1 + 4;
    }
    
    // required int32 confidence = 3;
    if (has_confidence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->confidence());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Ball::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ball* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ball*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ball::MergeFrom(const Ball& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_detect()->::man::vision::Detection::MergeFrom(from.detect());
    }
    if (from._has_bit(1)) {
      set_radius(from.radius());
    }
    if (from._has_bit(2)) {
      set_confidence(from.confidence());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ball::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ball::CopyFrom(const Ball& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ball::Swap(Ball* other) {
  if (other != this) {
    std::swap(detect_, other->detect_);
    std::swap(radius_, other->radius_);
    std::swap(confidence_, other->confidence_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Ball::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_detect()) {
    if (!this->detect().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Ball::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Ball::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Ball_reflection_;
}

// ===================================================================

#ifndef _MSC_VER
const int Frame::kImageFieldNumber;
const int Frame::kBallsFieldNumber;
const int Frame::kObjectsFieldNumber;
const int Frame::kLinesFieldNumber;
const int Frame::kCornersFieldNumber;
const int Frame::kRobotsFieldNumber;
#endif  // !_MSC_VER

Frame::Frame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Frame::InitAsDefaultInstance() {  image_ = const_cast< ::man::vision::Image*>(&::man::vision::Image::default_instance());
}

Frame::Frame(const Frame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Frame::SharedCtor() {
  _cached_size_ = 0;
  image_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame::~Frame() {
  SharedDtor();
}

void Frame::SharedDtor() {
  if (this != default_instance_) {
    delete image_;
  }
}

const ::google::protobuf::Descriptor* Frame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Frame_descriptor_;
}

const Frame& Frame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vision_2eproto();  return *default_instance_;
}

Frame* Frame::default_instance_ = NULL;

Frame* Frame::New() const {
  return new Frame;
}

void Frame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (image_ != NULL) image_->::man::vision::Image::Clear();
    }
  }
  balls_.Clear();
  objects_.Clear();
  lines_.Clear();
  corners_.Clear();
  robots_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional .man.vision.Image image = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_image()));
        if (input->ExpectTag(18)) goto parse_balls;
        break;
      }
      
      // repeated .man.vision.Ball balls = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_balls:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_balls()));
        if (input->ExpectTag(18)) goto parse_balls;
        if (input->ExpectTag(26)) goto parse_objects;
        break;
      }
      
      // repeated .man.vision.FieldObject objects = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_objects:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_objects()));
        if (input->ExpectTag(26)) goto parse_objects;
        if (input->ExpectTag(34)) goto parse_lines;
        break;
      }
      
      // repeated .man.vision.Line lines = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_lines:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_lines()));
        if (input->ExpectTag(34)) goto parse_lines;
        if (input->ExpectTag(42)) goto parse_corners;
        break;
      }
      
      // repeated .man.vision.Corner corners = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_corners:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_corners()));
        if (input->ExpectTag(42)) goto parse_corners;
        if (input->ExpectTag(50)) goto parse_robots;
        break;
      }
      
      // repeated .man.vision.Robot robots = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_robots:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_robots()));
        if (input->ExpectTag(50)) goto parse_robots;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Frame::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional .man.vision.Image image = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->image(), output);
  }
  
  // repeated .man.vision.Ball balls = 2;
  for (int i = 0; i < this->balls_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->balls(i), output);
  }
  
  // repeated .man.vision.FieldObject objects = 3;
  for (int i = 0; i < this->objects_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->objects(i), output);
  }
  
  // repeated .man.vision.Line lines = 4;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(4, this->lines(i), output);
  }
  
  // repeated .man.vision.Corner corners = 5;
  for (int i = 0; i < this->corners_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(5, this->corners(i), output);
  }
  
  // repeated .man.vision.Robot robots = 6;
  for (int i = 0; i < this->robots_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(6, this->robots(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Frame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .man.vision.Image image = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(1, this->image(), target);
  }
  
  // repeated .man.vision.Ball balls = 2;
  for (int i = 0; i < this->balls_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->balls(i), target);
  }
  
  // repeated .man.vision.FieldObject objects = 3;
  for (int i = 0; i < this->objects_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(3, this->objects(i), target);
  }
  
  // repeated .man.vision.Line lines = 4;
  for (int i = 0; i < this->lines_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(4, this->lines(i), target);
  }
  
  // repeated .man.vision.Corner corners = 5;
  for (int i = 0; i < this->corners_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(5, this->corners(i), target);
  }
  
  // repeated .man.vision.Robot robots = 6;
  for (int i = 0; i < this->robots_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(6, this->robots(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Frame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .man.vision.Image image = 1;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->image());
    }
    
  }
  // repeated .man.vision.Ball balls = 2;
  total_size += 1 * this->balls_size();
  for (int i = 0; i < this->balls_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->balls(i));
  }
  
  // repeated .man.vision.FieldObject objects = 3;
  total_size += 1 * this->objects_size();
  for (int i = 0; i < this->objects_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->objects(i));
  }
  
  // repeated .man.vision.Line lines = 4;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->lines(i));
  }
  
  // repeated .man.vision.Corner corners = 5;
  total_size += 1 * this->corners_size();
  for (int i = 0; i < this->corners_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->corners(i));
  }
  
  // repeated .man.vision.Robot robots = 6;
  total_size += 1 * this->robots_size();
  for (int i = 0; i < this->robots_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->robots(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Frame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Frame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Frame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Frame::MergeFrom(const Frame& from) {
  GOOGLE_CHECK_NE(&from, this);
  balls_.MergeFrom(from.balls_);
  objects_.MergeFrom(from.objects_);
  lines_.MergeFrom(from.lines_);
  corners_.MergeFrom(from.corners_);
  robots_.MergeFrom(from.robots_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_image()->::man::vision::Image::MergeFrom(from.image());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Frame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Frame::CopyFrom(const Frame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Frame::Swap(Frame* other) {
  if (other != this) {
    std::swap(image_, other->image_);
    balls_.Swap(&other->balls_);
    objects_.Swap(&other->objects_);
    lines_.Swap(&other->lines_);
    corners_.Swap(&other->corners_);
    robots_.Swap(&other->robots_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Frame::IsInitialized() const {
  
  if (has_image()) {
    if (!this->image().IsInitialized()) return false;
  }
  for (int i = 0; i < balls_size(); i++) {
    if (!this->balls(i).IsInitialized()) return false;
  }
  for (int i = 0; i < objects_size(); i++) {
    if (!this->objects(i).IsInitialized()) return false;
  }
  for (int i = 0; i < lines_size(); i++) {
    if (!this->lines(i).IsInitialized()) return false;
  }
  for (int i = 0; i < corners_size(); i++) {
    if (!this->corners(i).IsInitialized()) return false;
  }
  for (int i = 0; i < robots_size(); i++) {
    if (!this->robots(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Frame::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Frame::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Frame_reflection_;
}

}  // namespace vision
}  // namespace man
